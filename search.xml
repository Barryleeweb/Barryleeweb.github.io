<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[移动端适配]]></title>
      <url>https://barryleeweb.github.io/2017/08/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>移动端web开发相对于PC端web开发，我们可以庆幸不用兼容那么多浏览器了，但是随之而来的却是各种屏幕尺寸的适配，个人觉得，比PC端还要费精力。在使用了腾讯优测进行软件测试后，问题得到了有效解决。</p>
<h1 id="1-移动端布局方式"><a href="#1-移动端布局方式" class="headerlink" title="1.移动端布局方式"></a>1.移动端布局方式</h1><h2 id="1-1响应式布局"><a href="#1-1响应式布局" class="headerlink" title="1.1响应式布局"></a>1.1响应式布局</h2><p>简而言之，就是页面元素的位置随着屏幕尺寸的变化而变化，通常会用百分比来定位，而在设计上需要预留一些可被“压缩”的空间。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/0128/110509_Fkpj_2420477.jpg" alt="image"></p>
<p>如上图，其实就相当于页面被压矮了。<br><a id="more"></a></p>
<h2 id="1-2Cover布局"><a href="#1-2Cover布局" class="headerlink" title="1.2Cover布局"></a>1.2Cover布局</h2><p>就跟background-size的cover属性一样，保持页面的宽高比，取宽或高之中的较小者占满屏幕，超出的内容会被隐藏。此布局适用于主要内容集中在中部，边沿无重要内容的设计。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/0128/110536_8i2h_2420477.jpg" alt="image"></p>
<p>如上图，第一张是原设计稿，第二张把左右隐藏掉了一部分，第三张则是把上下隐藏掉了一部分。</p>
<h2 id="1-3Contain布局"><a href="#1-3Contain布局" class="headerlink" title="1.3Contain布局"></a>1.3Contain布局</h2><p>同样，也跟background-size的contain属性那样，保持页面的宽高比，取宽或高之中的较大者占满屏幕，不足的部分会用背景填充。个人比较推荐用这种方式，但在设计上需要背景为单色，或者是可平铺的背景。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/0128/110556_BSaM_2420477.jpg" alt="image"></p>
<p>如上图，红框部分为原始宽高比，根据不同屏幕尺寸进行缩放，并加背景填充。 </p>
<h1 id="2-常用的实现方法"><a href="#2-常用的实现方法" class="headerlink" title="2.常用的实现方法"></a>2.常用的实现方法</h1><h2 id="2-1样式缩放"><a href="#2-1样式缩放" class="headerlink" title="2.1样式缩放"></a>2.1样式缩放</h2><p>最省事的适配方法，直接用px为单位按视觉进行开发，然后通过计算屏幕与网页的宽高比，用transform:scale来对网页进行全局缩放。</p>
<p>不过此方法会有一个小问题，就是如果网页内有动画的话，缩放后会稍微降低页面性能，在低配的安卓机器上表现的比较明显，iOS上没发现有性能问题。</p>
<h2 id="2-2Rem缩放"><a href="#2-2Rem缩放" class="headerlink" title="2.2Rem缩放"></a>2.2Rem缩放</h2><p>Rem是个好东西呀，谁用谁知道，这里就不多做解释了。原理跟上面的样式缩放相通，只不过是通过Rem为单位来进行视觉开发，然后通过计算后改变html的front-size来对页面进行缩放。</p>
<p>关于以Rem为单位进行开发，目前比较流行Font-size=62.5%，而后1rem=10px的这种方法，有试过直接换成px也是可以的，就看个人的计算习惯吧。</p>
<h1 id="3-Rem缩放"><a href="#3-Rem缩放" class="headerlink" title="3.Rem缩放"></a>3.Rem缩放</h1><ul>
<li>rem的意思（根元素的font-size值）</li>
<li>viewport</li>
<li>DPR(device pixel ratio)</li>
<li>动态rem<h2 id="3-1-标签中的viewport"><a href="#3-1-标签中的viewport" class="headerlink" title="3.1 标签中的viewport"></a>3.1 <meta>标签中的viewport</h2>简单来讲，viewport就是浏览器上，用来显示网页的那一部分区域了，也就是说，浏览器的实际宽度，是和我们手机的宽度不一样的，无论你的手机 宽度是320px，还是640px，在手机浏览器内部的宽度，始终会是浏览器本身的viewport。</li>
</ul>
<p>对viewport的控制:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1 user-scalable=0&quot;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="3-2-关于我们的设备"><a href="#3-2-关于我们的设备" class="headerlink" title="3.2 关于我们的设备"></a>3.2 关于我们的设备</h2><h3 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念:"></a>三个概念:</h3><ul>
<li>PPI: 可以理解为屏幕的显示密度</li>
<li>DPR: 设备物理像素和逻辑像素的对应关系，即物理像素/逻辑像素</li>
<li>Resolution: 就是我们常说的分辨率</li>
</ul>
<h3 id="物理像素与逻辑像素-DPR"><a href="#物理像素与逻辑像素-DPR" class="headerlink" title="物理像素与逻辑像素(DPR):"></a>物理像素与逻辑像素(DPR):</h3><p>设备物理像素：</p>
<blockquote>
<p>通俗的讲设备屏幕有多少个可以闪烁的点 是一个具体的概念 比如iphone6横向就有750个可以改变颜色的点 类似与电视机 如果家里有10年前买的大头电视，你趴在屏幕前仔细看能看到一个个RGB的点 这就是设备的物理像素</p>
</blockquote>
<p>设备独立像素</p>
<blockquote>
<p>设备独立像素是一个虚拟的概念，如程序中的css 比如我们将一个div宽度设置为10像素 那么在pc上系统会将这个div显示在屏幕的10个点上</p>
</blockquote>
<p>以iphone6为例，在不做任何缩放的条件下，iphone6的获取到的’width-device’为375px,为屏幕的逻辑像素。而购买时我们所知的750px，则为屏幕的物理像素。</p>
<h3 id="CSS的问题"><a href="#CSS的问题" class="headerlink" title="CSS的问题:"></a>CSS的问题:</h3><p>以iphone6为例，我们可以知道，其实我们所写的1px，在iphone6上为2px的物理像素。所以，最后的，给出一个结论。就是我们写的1px，在移动端，是逻辑像素的1px，而非物理像素的1px。</p>
<h2 id="3-3-rem布局"><a href="#3-3-rem布局" class="headerlink" title="3.3 rem布局"></a>3.3 rem布局</h2><h3 id="3-3-1简介rem"><a href="#3-3-1简介rem" class="headerlink" title="3.3.1简介rem"></a>3.3.1简介rem</h3><p>如今市面上移动设备的分辨率大小不同，常用的px单位不再准确。为此，CSS3出了一个新单位——rem，rem是移动端神器，它完美解决了分辨率的适配问题</p>
<p>rem就是相对于根元素<html>的font-size来做计算</html></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">html&#123;</div><div class="line">    font-size：10px;</div><div class="line">&#125;</div><div class="line">.box&#123;</div><div class="line">    width:10rem;</div><div class="line">    height:10rem;</div><div class="line">    font-size:1.2rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个宽高各100px的box就出现了,有些像我们以前常用的em，不过rem是相对于根元素(<html>)的字体大小，em相对 于父元素的字体大小。</html></p>
<p>设计稿的像素/html的font-size=用来代替px的rem</p>
<h3 id="3-3-2屏幕适配"><a href="#3-3-2屏幕适配" class="headerlink" title="3.3.2屏幕适配"></a>3.3.2屏幕适配</h3><p>虽然很简单，但是移动设备那么多，我们又怎么根据手机屏幕的分辨率不同，去设置<html>的字体大小呢？</html></p>
<ul>
<li>通过CSS媒体查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">html&#123;</div><div class="line">    font-size:20px;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width:320px)&#123;</div><div class="line">    html&#123;</div><div class="line">        font-size:10px;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width:375px)&#123;</div><div class="line">    html&#123;</div><div class="line">        font-size:16px;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@media only screen and (min-width:414px)&#123;</div><div class="line">    html&#123;</div><div class="line">        font-size:20px;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过媒体查询的方式，只需要把常用的屏幕宽度考虑进去即可，能够满足大部分应用场景，不过这一做法不够严谨</p>
<ul>
<li>通过js计算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*代码如下</div><div class="line">*其中的参数1080根据自己的实际情况进行修改，这里的1080代表设计页面的原始宽度，可以参考psd的标准宽度，这是后字体使用rem也有了标准，psd上的字号如：40点 对应css中的rem的换算方式为40/100=0.4rem。</div><div class="line">*/</div><div class="line">(function (doc, win) &#123;</div><div class="line">    var docEl = doc.documentElement,</div><div class="line">        resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</div><div class="line">        recalc = function () &#123;</div><div class="line">            var clientWidth = docEl.clientWidth;</div><div class="line">            if (!clientWidth) return;</div><div class="line">            docEl.style.fontSize =Math.floor(100*(clientWidth / 1080))+ &apos;px&apos;;</div><div class="line">        &#125;;</div><div class="line">    if (!doc.addEventListener) return;</div><div class="line">    win.addEventListener(resizeEvt, recalc, false);</div><div class="line">    doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</div><div class="line">&#125;)(document,window);</div></pre></td></tr></table></figure>
<p>通过js设备的屏幕分辨率，可以计算出相应的字体的大小，这个方法可以适配所有屏幕的大小，这下就完美许多了。</p>
<p>不过有些时候会很麻烦，因为rem会涉及到换算的问题，比如70px的宽，根目录字体是12px,那换算公式为：70/12 = 5.83333333~，每次写一个单位都要用计算器去算，这工作可以让Less或者Sass等预处理器去完成。</p>
<h3 id="3-3-3DPR的问题"><a href="#3-3-3DPR的问题" class="headerlink" title="3.3.3DPR的问题"></a>3.3.3DPR的问题</h3><p>1px会出现什么问题？</p>
<p>我们的设备，是有物理像素和逻辑像素的。而假设我们的设计稿是750的，同时还是以iphone6为例，此时如果我们的viewport是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;</div></pre></td></tr></table></figure>
<p>之前说过，在不做任何缩放的条件下，iphone6获取到的viewport为375px。</p>
<p>然后我们的页面中有个div，他有一个边框值，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">	height: 5rem;</div><div class="line">	widht:5rem;</div><div class="line">	border: 1px solid #000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时我们写的1px，实际上是逻辑像素，而我们在iphone6上看到的是物理像素，于是这个时候，我们眼睛所看到的其实是2px（参考第二点第三个问题3.2）</p>
<p>所以此时我们需要在viewport上做文章了，此时先明确，如果要获取到真正的1px，那么我们需要这么做，将viewport改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;</div></pre></td></tr></table></figure>
<p>即对屏幕做0.5倍的缩放。这样，我们就能得到实际的1px。</p>
<p>我们还要明确一点，viewport的meta标签，我们这里也只能通过js来动态生成。</p>
<h3 id="3-3-4文字适配问题"><a href="#3-3-4文字适配问题" class="headerlink" title="3.3.4文字适配问题"></a>3.3.4文字适配问题</h3><p>对于一些标题性的文字，我们依然可以用rem。让他随着屏幕来进行缩放，因为标题性文字一般较大，而较大的文字，点阵对其影响就越小。这样，即使出现奇怪的尺寸，也能够让字体得到很好的渲染。</p>
<p>对于一些正文内容的文字（即站在使用者的角度，你不希望他进行缩放的文字）。我们采用px来进行处理。</p>
<h2 id="3-4-手淘的解决方案"><a href="#3-4-手淘的解决方案" class="headerlink" title="3.4 手淘的解决方案"></a>3.4 手淘的解决方案</h2><h3 id="3-4-1-rem布局-对比3-2-2JS"><a href="#3-4-1-rem布局-对比3-2-2JS" class="headerlink" title="3.4.1 rem布局(对比3.2.2JS)"></a>3.4.1 rem布局(对比3.2.2JS)</h3><p>用js获取到页面的宽度，然后对其进行宽度/10的处理，再将其写到html的font-size中。手淘的flexible.js里面的这一部分，并为了方便看懂做了些改写。大体就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function refreshRem()&#123;</div><div class="line"> 	var docEl = window.document.documentElement;</div><div class="line">    var width = docEl.documentElement.getBoundingClientRect().width;</div><div class="line"></div><div class="line">    var rootSize = width/10;</div><div class="line">    docEl.style.fontSize = rootSize + &apos;px&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-4-2-dpr的配置"><a href="#3-4-2-dpr的配置" class="headerlink" title="3.4.2 dpr的配置"></a>3.4.2 dpr的配置</h3><h3 id="3-4-3-文字的解决方案"><a href="#3-4-3-文字的解决方案" class="headerlink" title="3.4.3 文字的解决方案"></a>3.4.3 文字的解决方案</h3><p>在html上，加入了一个自定义属性，data-dpr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;html data-dpr=&apos;dpr&apos;&gt;&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>假如设计稿上某a标签是32px，那么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a&#123;</div><div class="line">	font-size: 16px</div><div class="line">&#125;</div><div class="line">/*iphone6*/</div><div class="line">[data-dpr=&apos;2&apos;] a&#123;</div><div class="line">	font-size: 32px</div><div class="line">&#125;</div><div class="line">/*iphone6plus*/</div><div class="line">[data-dpr=&apos;3&apos;] a&#123;</div><div class="line">	font-size: 32px</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-5-另一个解决方案"><a href="#3-5-另一个解决方案" class="headerlink" title="3.5 ==另一个解决方案=="></a>3.5 ==另一个解决方案==</h2><p>通过rem,viewport,以及dpr我们就可以完成我们的终极适配了，告别死板写法 不再这样写死 我们知道了设备的dpr就可以明确的知道缩放多少，而且这样还解决了很难解决的1px横线的问题<br>我们需要这样一段js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">(function (doc, win) &#123;</div><div class="line">    console.log(&quot;dpr:&quot;+win.devicePixelRatio); </div><div class="line">    var docEle = doc.documentElement,</div><div class="line">    isIos = navigator.userAgent.match(/iphone|ipod|ipad/gi),</div><div class="line">    dpr=Math.min(win.devicePixelRatio, 3);</div><div class="line">    scale = 1 / dpr,</div><div class="line"></div><div class="line">    resizeEvent = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;;</div><div class="line">    docEle.dataset.dpr = dpr;</div><div class="line"></div><div class="line">    var metaEle = doc.createElement(&apos;meta&apos;);</div><div class="line">    metaEle.name = &apos;viewport&apos;;</div><div class="line">    metaEle.content = &apos;initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale;</div><div class="line">    docEle.firstElementChild.appendChild(metaEle);</div><div class="line"> </div><div class="line">    var recalCulate = function  &#123;</div><div class="line">        var width = docEle.clientWidth;</div><div class="line">        if (width / dpr &gt; 640) &#123;</div><div class="line">            width = 640 * dpr;</div><div class="line">        &#125;</div><div class="line">        docEle.style.fontSize = 20 * (width / 750) + &apos;px&apos;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    recalCulate</div><div class="line">    if (!doc.addEventListener) return;</div><div class="line">    win.addEventListener(resizeEvent, recalCulate, false);</div><div class="line">&#125;)(document, window);</div></pre></td></tr></table></figure>
<ul>
<li>获取设备dpr</li>
<li>算出缩放比例 scale = 1/dpr</li>
<li>创建meta以及属性</li>
<li>将scale值赋给initial-scale，maximum-scale</li>
<li>meta插入到文档中</li>
<li>创建屏幕大小改变重新计算函数并监听</li>
</ul>
<h2 id="3-5-个人总结上面知识点"><a href="#3-5-个人总结上面知识点" class="headerlink" title="3.5 个人总结上面知识点"></a>3.5 个人总结上面知识点</h2><ul>
<li>了解rem,viewport,以及dpr</li>
<li>获取DPR,得到缩放scale = 1/dpr，并挂到meta</li>
<li>设置rem:docEle.style.fontSize</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.oschina.net/question/2420477_2150404" target="_blank" rel="external">参考链接1</a></li>
<li><a href="http://www.cnblogs.com/doseoer/p/5331755.html" target="_blank" rel="external">参考链接2</a></li>
<li><a href="http://www.cnblogs.com/slman86/p/5581865.html" target="_blank" rel="external">参考链接3</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 移动端及响应式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移动端适配 </tag>
            
            <tag> rem </tag>
            
            <tag> dpr </tag>
            
            <tag> viewport </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域问题]]></title>
      <url>https://barryleeweb.github.io/2017/08/09/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="1-同源"><a href="#1-同源" class="headerlink" title="1.同源"></a>1.同源</h1><h2 id="1-1含义"><a href="#1-1含义" class="headerlink" title="1.1含义"></a>1.1含义</h2><p>所谓“同源”指的是”三个相同“。</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<h2 id="1-2目的"><a href="#1-2目的" class="headerlink" title="1.2目的"></a>1.2目的</h2><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h2 id="1-3限制范围"><a href="#1-3限制范围" class="headerlink" title="1.3限制范围"></a>1.3限制范围</h2><ul>
<li>Cookie、LocalStorage 和 IndexedDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求无效（可以发送，但浏览器会拒绝接受响应）。<a id="more"></a>
<h2 id="1-4Cookie"><a href="#1-4Cookie" class="headerlink" title="1.4Cookie"></a>1.4Cookie</h2>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。</li>
</ul>
<p>举例来说，A网页是<a href="http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。" target="_blank" rel="external">http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。</a></p>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p>
<h2 id="1-5iframe"><a href="#1-5iframe" class="headerlink" title="1.5iframe"></a>1.5iframe</h2><p>iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。iframe窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的DOM。</p>
<h2 id="1-6片段识别符"><a href="#1-6片段识别符" class="headerlink" title="1.6片段识别符"></a>1.6片段识别符</h2><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<a href="http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="external">http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。</a></p>
<h2 id="1-7window-postMessage"><a href="#1-7window-postMessage" class="headerlink" title="1.7window.postMessage"></a>1.7window.postMessage</h2><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</div><div class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</div></pre></td></tr></table></figure>
<h2 id="1-8LocalStorage"><a href="#1-8LocalStorage" class="headerlink" title="1.8LocalStorage"></a>1.8LocalStorage</h2><p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。</p>
<h2 id="1-9AJAX"><a href="#1-9AJAX" class="headerlink" title="1.9AJAX"></a>1.9AJAX</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>==JSONP==</li>
<li>==WebSocket==</li>
<li>==CORS==</li>
</ul>
<h1 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h1><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<script>元素，由它向跨源网址发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function addScriptTag(src) &#123;</div><div class="line">  var script = document.createElement(&apos;script&apos;);</div><div class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</div><div class="line">  script.src = src;</div><div class="line">  document.body.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.onload = function () &#123;</div><div class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo(data) &#123;</div><div class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码通过动态添加<script>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo(&#123;</div><div class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
<h1 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3.WebSocket"></a>3.WebSocket</h1><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<h1 id="4-CORS"><a href="#4-CORS" class="headerlink" title="4.CORS"></a>4.CORS</h1><p>CORS是一个W3C标准，全称是“跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="4-1两种请求"><a href="#4-1两种请求" class="headerlink" title="4.1两种请求"></a>4.1两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要<strong>同时</strong>满足以下两大条件，就属于简单请求。</p>
<h3 id="请求方法是以下三种方法之一。"><a href="#请求方法是以下三种方法之一。" class="headerlink" title="请求方法是以下三种方法之一。"></a>请求方法是以下三种方法之一。</h3><ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<h3 id="HTTP的头信息不超出以下几种字段。"><a href="#HTTP的头信息不超出以下几种字段。" class="headerlink" title="HTTP的头信息不超出以下几种字段。"></a>HTTP的头信息不超出以下几种字段。</h3><ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="4-2简单请求"><a href="#4-2简单请求" class="headerlink" title="4.2简单请求"></a>4.2简单请求</h2><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
<h2 id="4-3非简单请求"><a href="#4-3非简单请求" class="headerlink" title="4.3非简单请求"></a>4.3非简单请求</h2><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var url = &apos;http://api.alice.com/cors&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.open(&apos;PUT&apos;, url, true);</div><div class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的HTTP头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OPTIONS /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>预检”请求用的请求方法是==OPTIONS==，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，“预检”请求的头信息包括两个特殊字段。</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
<h3 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h3><p>服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line">Server: Apache/2.0.61 (Unix)</div><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 0</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure>
<p>一旦服务器通过了“预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<h2 id="4-4与JSONP的比较"><a href="#4-4与JSONP的比较" class="headerlink" title="4.4与JSONP的比较"></a>4.4与JSONP的比较</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<p><a href="http://javascript.ruanyifeng.com/bom/same-origin.html">参考链接</a></p>
</script></p>]]></content>
      
        <categories>
            
            <category> 浏览器&amp;Ajax </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 同源 </tag>
            
            <tag> jsonp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js面向对象编程：封装]]></title>
      <url>https://barryleeweb.github.io/2017/08/09/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
<h2 id="1-生成实例对象的原始模式"><a href="#1-生成实例对象的原始模式" class="headerlink" title="1.生成实例对象的原始模式"></a>1.生成实例对象的原始模式</h2><p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　var Cat = &#123;</div><div class="line">　　　　name : &apos;&apos;,</div><div class="line">　　　　color : &apos;&apos;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var cat1 = &#123;&#125;; // 创建一个空对象</div><div class="line">　　　　cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值</div><div class="line">　　　　cat1.color = &quot;黄色&quot;;</div><div class="line">　　var cat2 = &#123;&#125;;</div><div class="line">　　　　cat2.name = &quot;二毛&quot;;</div><div class="line">　　　　cat2.color = &quot;黑色&quot;;</div></pre></td></tr></table></figure>
<p>缺点：</p>
<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。<br><a id="more"></a></p>
<h2 id="2-原始模式的改进"><a href="#2-原始模式的改进" class="headerlink" title="2.原始模式的改进"></a>2.原始模式的改进</h2><p>我们可以写一个函数，解决代码重复的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color) &#123;</div><div class="line">　　　　return &#123;</div><div class="line">　　　　　　name:name,</div><div class="line">　　　　　　color:color</div><div class="line">　　　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后生成实例对象，就等于是在调用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure>
<p>缺点：</p>
<p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3.构造函数模式"></a>3.构造函数模式</h2><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>
<p>比如，猫的原型对象现在可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　　　　this.name=name;</div><div class="line">　　　　this.color=color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在就可以生成实例对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.name); // 大毛</div><div class="line">alert(cat1.color); // 黄色</div></pre></td></tr></table></figure>
<p>这时cat1和cat2会自动含有一个==constructor==属性，指向它们的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat); //true</div><div class="line">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>
<p>Javascript还提供了一个==instanceof==运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1 instanceof Cat); //true</div><div class="line">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>
<h2 id="4-构造函数模式的问题"><a href="#4-构造函数模式的问题" class="headerlink" title="4.构造函数模式的问题"></a>4.构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。<br>请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　　　this.type = &quot;猫科动物&quot;;</div><div class="line">　　　　this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>还是采用同样的方法，生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.type); // 猫科动物</div><div class="line">　　cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>
<p>实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.eat == cat2.eat); //false</div></pre></td></tr></table></figure>
<h2 id="5-Prototype模式"><a href="#5-Prototype模式" class="headerlink" title="5.Prototype模式"></a>5.Prototype模式</h2><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　&#125;</div><div class="line">　　Cat.prototype.type = &quot;猫科动物&quot;;</div><div class="line">　　Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>
<p>然后，生成实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.type); // 猫科动物</div><div class="line">　　cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>
<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.eat == cat2.eat); //true</div></pre></td></tr></table></figure>
<h2 id="6-Prototype模式的验证方法"><a href="#6-Prototype模式的验证方法" class="headerlink" title="6.Prototype模式的验证方法"></a>6.Prototype模式的验证方法</h2><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。</p>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class="line">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class="line">alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure>
<h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(&quot;name&quot; in cat1); // true</div><div class="line">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>
<p>in运算符还可以用来遍历某个对象的所有属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> javascript&amp;ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6重点特性]]></title>
      <url>https://barryleeweb.github.io/2017/08/09/ES6%E9%87%8D%E7%82%B9%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="1-一些核心功能"><a href="#1-一些核心功能" class="headerlink" title="1. 一些核心功能"></a>1. 一些核心功能</h1><h2 id="1-1-let-const"><a href="#1-1-let-const" class="headerlink" title="1.1 let const"></a>1.1 let const</h2><p>ES5 通过 var 来申明变量，ES6 新添 let 和 const，且作用域是 块级作用域。</p>
<p>let 使用和 var 非常类似，let 不存在变量提升，也不允许重复申明，let 的声明只能在它所在的代码块有效</p>
<p>const 就是申明常量用的，一旦申明即被锁定，后面无法更改。<br><a id="more"></a></p>
<h2 id="1-2-解构赋值-Destructuring"><a href="#1-2-解构赋值-Destructuring" class="headerlink" title="1.2 解构赋值(Destructuring)"></a>1.2 解构赋值(Destructuring)</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>ES6 解构赋值基本语法 var [a, b, c] = [1, 2, 3];，从数组中取值，并按照先后次序来赋值。如果解构赋值不成功，就会返回 underfined，解构赋值也允许指定默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var [a, b] = [1];</div><div class="line">b // undefined</div><div class="line"></div><div class="line">// 指定默认值</div><div class="line">var [a, b = 2] = [1];</div><div class="line">b // 2</div></pre></td></tr></table></figure>
<p>除了数组，对象也可以解构赋值，但是数组是有顺序的，而对象没有顺序，如果想要成功赋值，必须与对象属性同名，才能成功赋值，否则返回 underfined：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;;</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line"></div><div class="line">var &#123;a, c&#125; = &#123;a: 1, b: 2&#125;;</div><div class="line">c // undefined</div></pre></td></tr></table></figure>
<p>字符串的解构赋值比较有意思，既可以把字符串当作可以迭代的数组，又可以当作对象，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var [a1,a2,a3,a4,a5] = &apos;hello&apos;;</div><div class="line">a2 // e</div><div class="line"></div><div class="line">var &#123;length : len&#125; = &apos;hello&apos;;</div><div class="line">len // 5</div></pre></td></tr></table></figure>
<h2 id="1-3-字符串模版（template-string）"><a href="#1-3-字符串模版（template-string）" class="headerlink" title="1.3 字符串模版（template string）"></a>1.3 字符串模版（template string）</h2><p>当我们要插入大段的html内容到文档中时，传统的写法非常麻烦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;#result&quot;).append(</div><div class="line">  &quot;There are &lt;b&gt;&quot; + basket.count + &quot;&lt;/b&gt; &quot; +</div><div class="line">  &quot;items in your basket, &quot; +</div><div class="line">  &quot;&lt;em&gt;&quot; + basket.onSale +</div><div class="line">  &quot;&lt;/em&gt; are on sale!&quot;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&quot;#result&quot;).append(`</div><div class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<h2 id="1-4-set-集合和-Map-结构"><a href="#1-4-set-集合和-Map-结构" class="headerlink" title="1.4 set 集合和 Map 结构"></a>1.4 set 集合和 Map 结构</h2><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><ul>
<li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li>
<li>Set 方法分为操作和遍历，操作方法有 add-添加成员， delete-删除成员， has-拥有判断返回布尔值， clear-清空集合。</li>
<li>遍历操作有 keys()，values()，entries()，forEach()，…，for of，map 和 filter 函数也可以用于 Set，不过要进行巧妙操作，先转换成数组，在进行操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1,2,3]);</div><div class="line">set = new Set([...set].map(a =&gt; a*2));</div><div class="line">// Set &#123;2, 4, 6&#125;</div></pre></td></tr></table></figure>
<h3 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h3><ul>
<li>Map 用来解决对象只接受字符串作为键名，Map 类似于对象，也是键值对集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>Map 可以通过 [set、 get、 has、 delete] 方法来操作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var m = new Map();</div><div class="line">var arr = [1, 2];</div><div class="line">m.set(arr, &apos;array&apos;);</div><div class="line">m.get(arr); // &apos;array&apos;</div><div class="line"></div><div class="line">m.has(arr) // true</div><div class="line">m.delete(arr) // true</div><div class="line">m.has(arr) // false</div></pre></td></tr></table></figure>
<h2 id="1-5-spread操作符（…）"><a href="#1-5-spread操作符（…）" class="headerlink" title="1.5 spread操作符（…）"></a>1.5 spread操作符（…）</h2><p>用于函数调用：myFunction(…iterableObj);</p>
<p>用于数组字面量：[…iterableObj, 4, 5, 6]</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Math.max()函数, 一般可以加入任意个参数</div><div class="line">Math.max(12, 13, 14, 15); // 15</div><div class="line"></div><div class="line">// 以数组的形式</div><div class="line">var arr = [1, 2, 3, 4];</div><div class="line">Math.max.apply(null, arr); // 4</div><div class="line"></div><div class="line">// 使用 &quot;...&quot;</div><div class="line">Math.max(...arr); // 4</div><div class="line">// 还可以加入其它的一些参数</div><div class="line">Math.max(...arr, 5, 10); // 10</div></pre></td></tr></table></figure>
<h3 id="数据解构"><a href="#数据解构" class="headerlink" title="数据解构"></a>数据解构</h3><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><h1 id="2-箭头函数-gt"><a href="#2-箭头函数-gt" class="headerlink" title="2. 箭头函数(=&gt;)"></a>2. 箭头函数(=&gt;)</h1><h2 id="2-1基本用法"><a href="#2-1基本用法" class="headerlink" title="2.1基本用法"></a>2.1基本用法</h2><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f = v =&gt; v;</div></pre></td></tr></table></figure>
<p>上面的箭头函数等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f = function(v) &#123;</div><div class="line">  return v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="2-2使用注意点"><a href="#2-2使用注意点" class="headerlink" title="2.2使用注意点"></a>2.2使用注意点</h2><p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this</strong>，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<h2 id="2-3函数绑定"><a href="#2-3函数绑定" class="headerlink" title="2.3函数绑定"></a>2.3函数绑定</h2><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p>
<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line">// 等同于</div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line">// 等同于</div><div class="line">bar.apply(foo, arguments);</div><div class="line"></div><div class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</div><div class="line">function hasOwn(obj, key) &#123;</div><div class="line">  return obj::hasOwnProperty(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-4箭头函数与常规函数对比"><a href="#2-4箭头函数与常规函数对比" class="headerlink" title="2.4箭头函数与常规函数对比"></a>2.4箭头函数与常规函数对比</h2><p>一个箭头函数与一个普通的函数在两个方面不一样：</p>
<ul>
<li>下列变量的构造是词法的： arguments ， super ， this ， new.target</li>
<li>不能被用作构造函数：没有内部方法 [[Construct]] （该方法允许普通的函数通过 new 调用），也没有 prototype 属性。因此， new (() =&gt; {}) 会抛出错误。</li>
</ul>
<h1 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h1><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.type = &apos;animal&apos;</div><div class="line">    &#125;</div><div class="line">    says(say)&#123;</div><div class="line">        console.log(this.type + &apos; says &apos; + say)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let animal = new Animal()</div><div class="line">animal.says(&apos;hello&apos;) //animal says hello</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super()</div><div class="line">        this.type = &apos;cat&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let cat = new Cat()</div><div class="line">cat.says(&apos;hello&apos;) //cat says hello</div></pre></td></tr></table></figure>
<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。</p>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。</p>
<p>super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<h1 id="4-Module模块化"><a href="#4-Module模块化" class="headerlink" title="4.Module模块化"></a>4.Module模块化</h1><p>ES6 之前，JS 一直没有 modules 体系，解决外部包的问题通过 CommonJS 和 AMD 模块加载方案，一个用于服务器，一个用于浏览器。ES6 提出的 modules （import／export）方案完全可以取代 CommonJS 和 AMD 成为浏览器和服务器通用的模块解决方案。</p>
<p>关于模块，就只有两个命令，import 用于导入其他模块，export 用于输出模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// profile.js</div><div class="line">var firstName = &apos;Michael&apos;;</div><div class="line">var lastName = &apos;Jackson&apos;;</div><div class="line">var year = 1958;</div><div class="line"></div><div class="line">export &#123;firstName, lastName, year&#125;;</div><div class="line"></div><div class="line">// main.js</div><div class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile&apos;;</div><div class="line">console.log(firstName, lastName) // Michael Jackson</div></pre></td></tr></table></figure>
<p>export 可以输出的内容很多，包括变量、函数、类，貌似都可以输出，还可以借助 export default 来加载默认输出。</p>
<h2 id="模块加载的实质"><a href="#模块加载的实质" class="headerlink" title="模块加载的实质"></a>模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</p>
<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>循环加载也比较有意思，经常能看到 nodejs 中出现加载同一个模块，而循环加载却不常见，nodejs 使用 CommonJS 模块机制，CommonJS 的循环加载采用的是加载多少，输出多少，就像是我们平时打了断点一样，会跳到另外一个文件，执行完在跳回来。</p>
<h1 id="5-Promise"><a href="#5-Promise" class="headerlink" title="5.Promise"></a>5.Promise</h1><h2 id="5-1为什么产生"><a href="#5-1为什么产生" class="headerlink" title="5.1为什么产生"></a>5.1为什么产生</h2><p>Promise的兴起，是因为异步方法调用中，往往会出现回调函数一环扣一环的情况。这种情况导致了回调金字塔问题的出现。不仅代码写起来费劲又不美观，而且问题复杂的时候，阅读代码的人也难以理解。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.save(data, function(data)&#123;</div><div class="line">    // do something...</div><div class="line">    db.save(data1, function(data)&#123;</div><div class="line">        // do something...</div><div class="line">        db.save(data2, function(data)&#123;</div><div class="line">            // do something...</div><div class="line">            done(data3); // 返回数据</div><div class="line">        &#125;)</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>假设有一个数据库保存操作，一次请求需要在三个表中保存三次数据。那么我们的代码就跟上面的代码相似了。这时候假设在第二个db.save出了问题怎么办？基于这个考虑，我们又需要在每一层回调中使用类似try…catch这样的逻辑。这个就是万恶的来源，也是node刚开始广为诟病的一点。</p>
<p>另外一个缺点就是，假设我们的三次保存之间并没有前后依赖关系，我们仍然需要等待前面的函数执行完毕, 才能执行下一步，而无法三个保存并行，之后返回一个三个保存过后需要的结果。（或者说实现起来需要技巧）</p>
<h2 id="5-2解决回调深渊Promise"><a href="#5-2解决回调深渊Promise" class="headerlink" title="5.2解决回调深渊Promise"></a>5.2解决回调深渊Promise</h2><p>Promise对象是一个有限状态机。它三个状态：</p>
<ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成，又称 Fulfilled））</li>
<li>Rejected（已失败）</li>
</ul>
<p>状态转换关系为：pending-&gt;fulfilled，pending-&gt;rejected。</p>
<h3 id="Promise形式"><a href="#Promise形式" class="headerlink" title="Promise形式"></a>Promise形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function func(resolve, reject)&#123;</div><div class="line">    // do somthing, maybe async</div><div class="line">    if (success)&#123;</div><div class="line">      return resolve(data);</div><div class="line">    &#125; else &#123;</div><div class="line">      return reject(data);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(function(data)&#123;</div><div class="line">    // do something... e.g</div><div class="line">    console.log(data);</div><div class="line">&#125;, function(err)&#123;</div><div class="line">    // deal the err.</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Promise数据流动"><a href="#Promise数据流动" class="headerlink" title="Promise数据流动"></a>Promise数据流动</h3><p>promise的then方法依然能够返回一个Promise对象，这样我们就又能用下一个then来做一样的处理。</p>
<ul>
<li>假设第一个then的第一个回调没有返回一个Promise对象，那么第二个then的调用者还是原来的Promise对象，只不过其resolve的值变成了第一个then中第一个回调函数的返回值。</li>
<li>假设第一个then的第一个回调函数返回了一个Promise对象，那么第二个then的调用者变成了这个新的Promise对象，第二个then等待这个新的Promise对象resolve或者reject之后执行回调。</li>
<li>如果任意地方遇到了错误，则错误之后交给遇到的第一个带第二个回调函数的then的第二个回调函数来处理。可以理解为错误一直向后reject, 直到被处理为止。</li>
</ul>
<h3 id="控制并发的Promise"><a href="#控制并发的Promise" class="headerlink" title="控制并发的Promise"></a>控制并发的Promise</h3><p>Promise有一个”静态方法”——Promise.all(注意并非是promise.prototype)， 这个方法接受一个元素是Promise对象的数组。</p>
<h3 id="将其他对象变为Promise对象"><a href="#将其他对象变为Promise对象" class="headerlink" title="将其他对象变为Promise对象"></a>将其他对象变为Promise对象</h3><p>Promise.resovle方法，可以将不是Promise对象作为参数，返回一个Promise对象。</p>
<h1 id="6-Generator"><a href="#6-Generator" class="headerlink" title="6.Generator"></a>6.Generator</h1><h1 id="7-async"><a href="#7-async" class="headerlink" title="7.async"></a>7.async</h1><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<h2 id="7-1async函数对-Generator-函数的改进"><a href="#7-1async函数对-Generator-函数的改进" class="headerlink" title="7.1async函数对 Generator 函数的改进"></a>7.1async函数对 Generator 函数的改进</h2><h3 id="内置执行器"><a href="#内置执行器" class="headerlink" title="内置执行器"></a>内置执行器</h3><p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<h3 id="更好的语义"><a href="#更好的语义" class="headerlink" title="更好的语义"></a>更好的语义</h3><p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<h3 id="更广的适用性"><a href="#更广的适用性" class="headerlink" title="更广的适用性"></a>更广的适用性</h3><p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<h3 id="返回值是-Promise"><a href="#返回值是-Promise" class="headerlink" title="返回值是 Promise"></a>返回值是 Promise</h3><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
<h2 id="7-2async-函数与-Promise、Generator-函数的比较"><a href="#7-2async-函数与-Promise、Generator-函数的比较" class="headerlink" title="7.2async 函数与 Promise、Generator 函数的比较"></a>7.2async 函数与 Promise、Generator 函数的比较</h2><p>假定某个 DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<h3 id="Promise-的写法："><a href="#Promise-的写法：" class="headerlink" title="Promise 的写法："></a>Promise 的写法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function chainAnimationsPromise(elem, animations) &#123;</div><div class="line"></div><div class="line">  // 变量ret用来保存上一个动画的返回值</div><div class="line">  var ret = null;</div><div class="line"></div><div class="line">  // 新建一个空的Promise</div><div class="line">  var p = Promise.resolve();</div><div class="line"></div><div class="line">  // 使用then方法，添加所有动画</div><div class="line">  for(var anim of animations) &#123;</div><div class="line">    p = p.then(function(val) &#123;</div><div class="line">      ret = val;</div><div class="line">      return anim(elem);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 返回一个部署了错误捕捉机制的Promise</div><div class="line">  return p.catch(function(e) &#123;</div><div class="line">    /* 忽略错误，继续执行 */</div><div class="line">  &#125;).then(function() &#123;</div><div class="line">    return ret;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然 Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来</p>
<h3 id="Generator-函数的写法"><a href="#Generator-函数的写法" class="headerlink" title="Generator 函数的写法"></a>Generator 函数的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function chainAnimationsGenerator(elem, animations) &#123;</div><div class="line"></div><div class="line">  return spawn(function*() &#123;</div><div class="line">    var ret = null;</div><div class="line">    try &#123;</div><div class="line">      for(var anim of animations) &#123;</div><div class="line">        ret = yield anim(elem);</div><div class="line">      &#125;</div><div class="line">    &#125; catch(e) &#123;</div><div class="line">      /* 忽略错误，继续执行 */</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。</p>
<h3 id="async-函数的写法"><a href="#async-函数的写法" class="headerlink" title="async 函数的写法"></a>async 函数的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async function chainAnimationsAsync(elem, animations) &#123;</div><div class="line">  var ret = null;</div><div class="line">  try &#123;</div><div class="line">    for(var anim of animations) &#123;</div><div class="line">      ret = await anim(elem);</div><div class="line">    &#125;</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">    /* 忽略错误，继续执行 */</div><div class="line">  &#125;</div><div class="line">  return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>
<p><a href="https://segmentfault.com/a/1190000004365693" target="_blank" rel="external">参考链接1</a><br><a href="http://web.jobbole.com/87140/" target="_blank" rel="external">参考链接2</a><br><a href="https://segmentfault.com/a/1190000007817990#articleHeader16" target="_blank" rel="external">参考链接3</a></p>
]]></content>
      
        <categories>
            
            <category> javascript&amp;ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> Promise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IMWeb面试题整理]]></title>
      <url>https://barryleeweb.github.io/2017/08/06/IMWeb%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<ol>
<li>什么是盒子模型？</li>
<li>简述一下src与href的区别?</li>
<li>简述同步和异步的区别?</li>
<li>怎样添加、移除、移动、复制、创建和查找节点？</li>
<li>一次完整的HTTP事务是怎样的一个过程？</li>
<li>你所了解到的Web攻击技术?</li>
<li>ajax是什么?ajax的交互模型?同步和异步的区别?如何解决跨域问题?</li>
<li>什么叫优雅降级和渐进增强？</li>
<li>在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</li>
<li>浏览器本地存储?<a id="more"></a></li>
<li>线程与进程的区别?</li>
<li>请说出三种减少页面加载时间的方法。</li>
<li>null和undefined的区别？</li>
<li>new操作符具体干了什么呢?</li>
<li>哪些操作会造成内存泄漏？<br>16.对Node的优点和缺点提出了自己的看法？</li>
<li>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</li>
<li>HTTP状态码</li>
<li>请解释一下 JavaScript 的同源策略。</li>
<li>GET和POST的区别，何时使用POST？</li>
<li>XHTML和HTML有什么区别?</li>
<li>什么是语义化的HTML?</li>
<li>常见的浏览器内核有哪些？</li>
<li>HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？</li>
<li>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</li>
<li>谈谈This对象的理解。</li>
<li>谈一谈JavaScript作用域链?</li>
<li>如何理解JavaScript原型链?</li>
<li>JavaScript如何实现继承？</li>
<li>清除浮动有哪些方式？比较好的方式是哪一种？</li>
<li>box-sizing常用的属性有哪些？分别有什么作用？</li>
<li>Doctype作用？标准模式与兼容模式各有什么区别? </li>
<li>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</li>
<li>页面导入样式时，使用link和@import有什么区别？</li>
<li>介绍一下你对浏览器内核的理解？</li>
<li>IE和DOM事件流的区别?</li>
<li>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</li>
<li>CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?</li>
<li>在JavaScript我们会遇到闭包，请你们根据自己的理解分析一下什么是闭包？闭包有什么好处？使用闭包要注意什么？</li>
<li>如何阻止事件冒泡和默认事件（程序）</li>
</ol>
<h1 id="面试题答案"><a href="#面试题答案" class="headerlink" title="面试题答案"></a><a href="https://zhuanlan.zhihu.com/imweb" target="_blank" rel="external">面试题答案</a></h1>]]></content>
      
        <categories>
            
            <category> Tencent_IMWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《图解HTTP》笔记（一）]]></title>
      <url>https://barryleeweb.github.io/2017/08/05/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h1><h2 id="TCP-IP的分层"><a href="#TCP-IP的分层" class="headerlink" title="TCP/IP的分层"></a>TCP/IP的分层</h2><p>应用层，传输层，网络层，数据链路层</p>
<ul>
<li>应用层：FTP,DNS,HTTP；</li>
<li>传输层：TCP,UDP；</li>
<li>网络层:IP，处理网络上流动的数据包；</li>
<li>数据链路层：处理连接网络的硬件部分。<br>域名-IP-MAC</li>
</ul>
<p>DNS-客户端-HTTP请求报文-TCP将HTTP报文分为多个报文段-IP路由器中转-TCP重组报文-HTTP处理请求-服务器</p>
<p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。<br><a id="more"></a></p>
<h1 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h1><p>HTTP协议使用URI定位互联网上的资源</p>
<h2 id="告知服务器意图的HTTP方法："><a href="#告知服务器意图的HTTP方法：" class="headerlink" title="告知服务器意图的HTTP方法："></a>告知服务器意图的HTTP方法：</h2><ul>
<li>GET(获取资源)</li>
<li>POST(传输实体主体)</li>
<li>PUT（传输文件）</li>
<li>HEAD(获取报文首部)</li>
<li>DELETE(删除文件)</li>
<li>OPTIONS(询问支持的方法)</li>
<li>TRACE(追踪路径，可能会有代理服务器中转)</li>
<li>CONNECT(要求用隧道协议连接代理)</li>
</ul>
<h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP初始版本中，每进行一次HTTP通信就要断开一次TCP连接。<br>例如：浏览一个网页，获取HTML文档一次，获取图片一次。。。</p>
<p>解决办法：</p>
<ul>
<li>持久连接：只要任意一端没有明确提出断开连接，则保持TCP连接状态，HTTP/1.1中默认持久连接</li>
<li>管线化：不用等待响应可直接发送下一个请求</li>
</ul>
<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2><p>HTTP是无状态协议，不对之前发生过的请求和响应状态进行状态。</p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<ul>
<li>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。</li>
<li>当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。</li>
<li>服务器发现客户端发送过来的Cookie后，会检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
</ul>
<h1 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h1><h2 id="1-HTTP报文"><a href="#1-HTTP报文" class="headerlink" title="1.HTTP报文"></a>1.HTTP报文</h2><ul>
<li>报文首部：通用首部（请求响应报文都有），请求首部（请求报文），响应首部（响应报文），实体首部（请求响应报文都有），Cookie，其他</li>
<li>空行（CR+LF）</li>
<li>报文主体</li>
</ul>
<h2 id="2-编码提升传输效率"><a href="#2-编码提升传输效率" class="headerlink" title="2.编码提升传输效率"></a>2.编码提升传输效率</h2><h3 id="报文主体和实体主体："><a href="#报文主体和实体主体：" class="headerlink" title="报文主体和实体主体："></a>报文主体和实体主体：</h3><ul>
<li>报文：HTTP通信基本单位，8位组字节流组成</li>
<li>实体：请求或响应的有效载荷数据，分为实体首部，实体主体</li>
</ul>
<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>
<p>通常报文主体等于实体主体，只有当传说中有编码操作时，实体主体内容发生变化，导致它和报文主体产生差异</p>
<h3 id="内容编码："><a href="#内容编码：" class="headerlink" title="内容编码："></a>内容编码：</h3><ul>
<li>应用在实体内容上的编码格式，并保持实体信息原样压缩。编码后的实体由客户端接收并解码。</li>
<li>编码类型：<strong>gzip</strong>，compress，deflate，identity</li>
</ul>
<h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><ul>
<li>HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
<li>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。功能称为分块传输编码（Chunked Transfer Coding）</li>
</ul>
<h2 id="3-发送多种数据的多部分对象集合"><a href="#3-发送多种数据的多部分对象集合" class="headerlink" title="3.发送多种数据的多部分对象集合"></a>3.发送多种数据的多部分对象集合</h2><p>发送邮件时，可以添加多份附件，这是采用了MIME机制，允许处理文本，图片，视频等不同类型的数据。</p>
<p>在MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。</p>
<h2 id="4-获取部分内容的范围请求"><a href="#4-获取部分内容的范围请求" class="headerlink" title="4.获取部分内容的范围请求"></a>4.获取部分内容的范围请求</h2><ul>
<li>下载大尺寸的图片过程中如果网络中断，那就必须重头开始。</li>
<li>为了解决问题，需要恢复机制，即从之前下载中断处恢复下载</li>
<li>要实现恢复需要指定下载实体范围，指定范围发送的请求叫做范围请求。</li>
<li>针对范围请求，响应会返回状态码==206 Partial Content==</li>
<li>5001~10000字节：Range：bytes=5001-10000</li>
</ul>
<h2 id="5-内容协商返回最合适的内容"><a href="#5-内容协商返回最合适的内容" class="headerlink" title="5.内容协商返回最合适的内容"></a>5.内容协商返回最合适的内容</h2><ul>
<li>同一个Web网站有可能存在着多份相同内容的页面。比如英语版和中文版的Web页面。</li>
<li>内容协商机制是指客户端和服务器就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。</li>
<li>内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</li>
<li>请求报文中的某些首部字段就是判断的基准。Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</li>
<li>服务器驱动协商：服务器端自动处理</li>
<li>客户端驱动协商：用户手动选择</li>
<li>透明协商：结合体</li>
</ul>
<h1 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h1><h2 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h2><ul>
<li>1XX - 信息性状态码</li>
<li>2XX - 成功状态码</li>
<li>3XX - 重定向状态码</li>
<li>4XX - 客户端错误状态码</li>
<li>5XX - 服务器错误状态码</li>
</ul>
<p>实际上经常使用的大概只有14种</p>
<h2 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h2><ul>
<li>200 OK</li>
<li>204 No Content 返回的响应报文中不含实体的主体部分</li>
<li>206 Partial Content 客户端进行了范围请求</li>
</ul>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><ul>
<li>301 Moved Permanently 永久性重定向，表示请求的资源已被分配了新的URI</li>
<li>302 Found 临时性重定向，本次能使用新的URI访问，URI还可能改变</li>
<li>303 See Other 与302功能相同，但必须用GET方法定向获取</li>
<li>304 Not Modified 服务器端资源未改变，可直接使用客户端未过期的缓存</li>
<li>307 Temporary Redirect 临时性重定向，与302功能相同，不会从POST变成GET</li>
</ul>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><ul>
<li>400 Bad Request 请求报文存在语法错误</li>
<li>401 Unauthorized 发送的请求需要通过HTTP认证（BASIC认证，DIGEST认证）</li>
<li>403 Forbidden 请求资源的访问被服务器拒绝了</li>
<li>404 Not Found 服务器上无法找到请求的资源</li>
</ul>
<h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><ul>
<li>500 Internal Server Error 服务器端执行请求时发生错误</li>
<li>503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
<h1 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h1><p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率。</p>
<h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><ul>
<li><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假象已具有多台服务器。</p>
</li>
<li><p>互联网上，域名通过DNS服务映射到IP地址之后访问目标网站。当请求发送到服务器时，已经是IP地址形式了。</p>
</li>
<li><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p>
</li>
</ul>
<h2 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h2><p>HTTP通信时，除客户端和服务器外，还有一些用于<strong>通信数据转发</strong>的应用程序，例如代理、网关和隧道。</p>
<ul>
<li>代理：有转发功能的<strong>应用程序</strong>，会添加Via首部信息，可分为缓存代理（会预先将资源的副本缓存）和透明代理（不加工报文）</li>
<li>网关：转发其他服务器通信数据的<strong>服务器</strong>，提高安全性</li>
<li>隧道：在相隔甚远的客户端和服务器之间中转，并保持通信连接的<strong>应用程序</strong>。隧道是透明的，可以使用SSL加密通信。</li>
</ul>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此节省了通信流量和时间。</p>
<ul>
<li><strong>缓存有效期限</strong>:<br>即使存在缓存，也会因此客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获得新资源。</li>
<li><strong>客户端的缓存</strong>：缓存不仅存在与缓存服务器内，还可以存在客户端浏览器中。和缓存服务器一样，当判定缓存过期后，会向源服务器确认资源的有效性。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git使用方法]]></title>
      <url>https://barryleeweb.github.io/2017/08/04/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="上传本地代码到GitHub"><a href="#上传本地代码到GitHub" class="headerlink" title="上传本地代码到GitHub"></a>上传本地代码到GitHub</h1><h3 id="1-建立git仓库"><a href="#1-建立git仓库" class="headerlink" title="1.建立git仓库"></a>1.建立git仓库</h3><p>git init</p>
<h3 id="2-将项目的所有文件添加到仓库中"><a href="#2-将项目的所有文件添加到仓库中" class="headerlink" title="2.将项目的所有文件添加到仓库中"></a>2.将项目的所有文件添加到仓库中</h3><p>git add .</p>
<h3 id="3-将add的文件commit到仓库"><a href="#3-将add的文件commit到仓库" class="headerlink" title="3.将add的文件commit到仓库"></a>3.将add的文件commit到仓库</h3><p>git commit -m “创建仓库”</p>
<h3 id="4-去github上创建自己的Repository"><a href="#4-去github上创建自己的Repository" class="headerlink" title="4.去github上创建自己的Repository"></a>4.去github上创建自己的Repository</h3><p>复制仓库的https地址</p>
<h3 id="5-将本地的仓库关联到github上"><a href="#5-将本地的仓库关联到github上" class="headerlink" title="5.将本地的仓库关联到github上"></a>5.将本地的仓库关联到github上</h3><p>git remote add origin <a href="https://github.com/。。。" target="_blank" rel="external">https://github.com/。。。</a></p>
<h3 id="6-上传github之前，要先pull一下"><a href="#6-上传github之前，要先pull一下" class="headerlink" title="6.上传github之前，要先pull一下"></a>6.上传github之前，要先pull一下</h3><p>git pull origin master</p>
<h3 id="7-上传代码到github远程仓库"><a href="#7-上传代码到github远程仓库" class="headerlink" title="7.上传代码到github远程仓库"></a>7.上传代码到github远程仓库</h3><p>git push -u origin master<br><a id="more"></a></p>
<h1 id="拷贝代码"><a href="#拷贝代码" class="headerlink" title="拷贝代码"></a>拷贝代码</h1><p>git clone <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>…</p>
<h1 id="创建-gitignore-文件"><a href="#创建-gitignore-文件" class="headerlink" title="创建 .gitignore 文件"></a>创建 .gitignore 文件</h1><ul>
<li>输入 touch .gitignore ，生成“.gitignore”文件。</li>
<li>在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.deploy_git/</div><div class="line">node_modules/</div><div class="line">public/</div></pre></td></tr></table></figure>
<h1 id="关于分支Branch"><a href="#关于分支Branch" class="headerlink" title="关于分支Branch"></a>关于分支Branch</h1><h2 id="1-什么是分支Branch？"><a href="#1-什么是分支Branch？" class="headerlink" title="1. 什么是分支Branch？"></a>1. 什么是分支Branch？</h2><p>GitHub仓库默认有一个master的分支，当我们在master分支开发过程中接到一个新的功能需求，我们就可以新建一个分支同步开发而互不影响，开发完成后，在合并merge到主分支master上。</p>
<h2 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2.分支操作"></a>2.分支操作</h2><p>现在我们需要合并两个分支：”master” 和 “gh-pages”</p>
<ul>
<li>打开 Git Shell</li>
<li>输入命令 git branch，我们可以看到我们目前的两个分支</li>
<li>输入命令git branch new_branch，创建一个新的分支 new_branch</li>
<li>输入命令 git checkout gh-pages，我们可以切换分支</li>
<li>or : 新建一个分支并且立即切换到新建的分支上，输入命令 git checkout -b new_branch_ha</li>
<li>合并分支，输入命令git merge gh-pages 报错！ fatal：refusing to merge unrelated histories.</li>
<li>解决方法：在命令后面加上一句“–allow-unrelated-histories”，即完整的命令为“git merge gh-pages –allow-unrelated-histories”,可以看到 gh-pages分支上的文件全部合并到了 master分支上</li>
<li>我们需要输入命令“git push”，可以看到我们的代码已经同步到仓库 test.github.com 上啦</li>
<li>删除分支，刚刚我们在第4步新建了一个多余的分支“new_branch_ha”需要删掉，我们首先输入命令“git branch”查看当前的分支有哪些，然后输入命令“git branch -D new_branch_ha”删除分支“new_branch_ha”，最后我们输入命令“git branch”查看分支已经被我们成功删除。</li>
</ul>
<p>另外：</p>
<p>“git merge gh-pages –allow-unrelated-histories”之后如果出现Please enter a commit message to explain why this merge is necessary.<br>解决：</p>
<ul>
<li>按键盘左上角”Esc”</li>
<li>输入”:wq”,注意是冒号+wq,按回车键即可</li>
</ul>
<h1 id="关于删除文件"><a href="#关于删除文件" class="headerlink" title="关于删除文件"></a>关于删除文件</h1><ol>
<li>先添加一个新文件test.txt到Git并且提交：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add test.txt</div><div class="line">$ git commit -m &quot;add test.txt&quot;</div></pre></td></tr></table></figure>
<ol>
<li><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm test.txt</div></pre></td></tr></table></figure>
</li>
<li><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure>
<ol>
<li>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git rm test.txt</div><div class="line">rm &apos;test.txt&apos;</div><div class="line">$ git commit -m &quot;remove test.txt&quot;</div></pre></td></tr></table></figure>
<p>文件就从版本库中被删除了。</p>
<ol>
<li>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- test.txt</div></pre></td></tr></table></figure>
<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<ol>
<li>总结：</li>
</ol>
<p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h1 id="创建gh-pages分支"><a href="#创建gh-pages分支" class="headerlink" title="创建gh-pages分支"></a>创建gh-pages分支</h1><p>之前的工作只是将我们的代码发布到了github上demo仓库的master分支上，当然你也可以不发布，而我们的展示页面代码必须发布到名为“gh-pages”的分支上。方法很简单，我们只需要在github的demo项目页面手动创建gh-pages分支即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1808251-9c330c0784cf84d2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>选择Branch：master，创建gh-pages</p>
<ol>
<li>新建并切换到gh-pages分支</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout --orphan gh-pages</div></pre></td></tr></table></figure>
<ol>
<li>之后的操作和之前一样，只是push的时候是gh-pages</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add *</div><div class="line">git commit -m &quot;update&quot;</div><div class="line">git push -u origin gh-pages</div></pre></td></tr></table></figure>
<ol>
<li>访问页面<br>创建并上传文件至gh-pages之后，我们就可以访问如下url来查看自己的demo了：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://(user_name|org_name).github.io/repo_name</div></pre></td></tr></table></figure>
<ol>
<li>github中的master<strong>自动同步</strong>到gh-pages<br>将如下代码复制到.git目录中的config文件中,位置是在[remote “origin”]这个段里面:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">push = +refs/heads/master:refs/heads/gh-pages</div><div class="line">push = +refs/heads/master:refs/heads/master</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> git&amp;blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串及数组操作]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="1-判断回文字符串"><a href="#1-判断回文字符串" class="headerlink" title="1.判断回文字符串"></a>1.判断回文字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function palindrome(str)&#123;</div><div class="line">	// \W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</div><div class="line">	var re = /[\W_]/g;</div><div class="line">	// 将字符串变成小写字符,并干掉除字母数字外的字符</div><div class="line">	var lowRegStr = str.toLowerCase().replace(re,&apos;&apos;);</div><div class="line">	// 如果字符串lowRegStr的length长度为0时，字符串即是palindrome</div><div class="line">	if(lowRegStr.length===0)</div><div class="line">		return true;</div><div class="line">	// 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome</div><div class="line">	if(lowRegStr[0]!=lowRegStr[lowRegStr.length-1])</div><div class="line">		return false;</div><div class="line">	//递归</div><div class="line">	return palindrome(lowRegStr.slice(1,lowRegStr.length-1));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-翻转字符串"><a href="#2-翻转字符串" class="headerlink" title="2.翻转字符串"></a>2.翻转字符串</h3><p><strong>反向遍历字符串</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function reverseString(str)&#123;</div><div class="line">	var tmp = &apos;&apos;;</div><div class="line">	for(var i=str.length-1;i&gt;=0;i--)</div><div class="line">		tmp += str[i];</div><div class="line">	return tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>转化成array操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function reverseString2(str)&#123;</div><div class="line">	var arr = str.split(&quot;&quot;);</div><div class="line">	var i = 0,j = arr.length-1;</div><div class="line">	while(i&lt;j)&#123;</div><div class="line">	    tmp = arr[i];</div><div class="line">	    arr[i] = arr[j];</div><div class="line">	    arr[j] = tmp;</div><div class="line">	    i++;</div><div class="line">	    j--;</div><div class="line">	&#125;</div><div class="line">	return arr.join(&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为str[i]是只读的，不能str[0]=str[1]这样操作。</p>
<p>如果允许用reverse()，也可以用’str’.split(‘’).reverse().join(‘’)实现。</p>
<h3 id="3-生成指定长度随机字符串"><a href="#3-生成指定长度随机字符串" class="headerlink" title="3.生成指定长度随机字符串"></a>3.生成指定长度随机字符串</h3><p>配合模糊等效果可以生成个验证码- -<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function randomString(n)&#123;</div><div class="line">	var str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;</div><div class="line">	var tmp = &apos;&apos;;</div><div class="line">	for(var i=0;i&lt;n;i++)</div><div class="line">	    tmp += str.charAt(Math.round(Math.random()*str.length));</div><div class="line">	return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-统计字符串中次数最多字母"><a href="#4-统计字符串中次数最多字母" class="headerlink" title="4.统计字符串中次数最多字母"></a>4.统计字符串中次数最多字母</h3><p>利用Object中key的唯一性，利用key来进行筛选，然后计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function findMaxDuplicateChar(str) &#123;</div><div class="line">    if(str.length == 1) &#123;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">    var charObj = &#123;&#125;;</div><div class="line">    for(var i = 0; i &lt; str.length; i++) &#123;</div><div class="line">        if(!charObj[str.charAt(i)]) &#123;</div><div class="line">            charObj[str.charAt(i)] = 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            charObj[str.charAt(i)] += 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var maxChar = &apos;&apos;,</div><div class="line">        maxValue = 1;</div><div class="line">    for(var k in charObj) &#123;</div><div class="line">        if(charObj[k] &gt;= maxValue) &#123;</div><div class="line">            maxChar = k;</div><div class="line">            maxValue = charObj[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return maxChar + &apos;：&apos; + maxValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><p>还是利用Object中key的唯一性，利用key来进行筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function unique(arr)&#123;</div><div class="line">	var obj = &#123;&#125;</div><div class="line">	var data = []</div><div class="line">	for(var i in arr)&#123;</div><div class="line">	    if(!obj[arr[i]])&#123;</div><div class="line">	        obj[arr[i]] = true;</div><div class="line">	        data.push(arr[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-Number数组中最大差值"><a href="#2-Number数组中最大差值" class="headerlink" title="2.Number数组中最大差值"></a>2.Number数组中最大差值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function getMaxProfit(arr)&#123;</div><div class="line">    var min = arr[0], max = arr[0];</div><div class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">        if(arr[i]&lt;min)</div><div class="line">            min = arr[i];</div><div class="line">		if(arr[i]&gt;max)</div><div class="line">		    max = arr[i];</div><div class="line">	&#125;</div><div class="line">	return max - min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据结构&amp;算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见排序及查找算法]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Javascript实现八大排序"><a href="#Javascript实现八大排序" class="headerlink" title="Javascript实现八大排序"></a>Javascript实现八大排序</h1><p><a href="http://www.jb51.net/article/88392.htm" target="_blank" rel="external">参考链接1</a><br><a href="http://www.qdfuns.com/notes/36539/24a66634ecba54ab3d8f7407168754f2.html" target="_blank" rel="external">参考链接2</a><br><a href="http://blog.csdn.net/hguisu/article/details/7776068/" target="_blank" rel="external">参考链接3</a></p>
<p>排序算法，分为内部排序和外部排序。内部排序要使用内存，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。这里只探讨内部排序。</p>
<ol>
<li>交换排序：冒泡排序和快速排序</li>
<li>插入排序：直接插入排序和希尔排序</li>
<li>选择排序：简单选择排序和堆排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ol>
<p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</p>
<p><strong>快速排序</strong>：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。<br><a id="more"></a></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><ul>
<li>原理：临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换,这样一趟过去后,最大或最小的数字被交换到了最后一位,然后再从头开始进行两两比较交换,直到倒数第二位时结束</li>
<li>时间复杂度：平均情况：O（n2）  最好情况：O（n） 最坏情况：O（n2）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(arr)&#123;</div><div class="line">	var i = j = 0;</div><div class="line">	for(i=1;i&lt;arr.length;i++)&#123;</div><div class="line">		for(j=0;j&lt;=arr.length-i;j++)&#123;</div><div class="line">			var temp = 0;</div><div class="line">			if(arr[j]&gt;arr[j+1])&#123;</div><div class="line">				temp = arr[j];</div><div class="line">				arr[j] = arr[j+1];</div><div class="line">				arr[j+1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h2><ul>
<li>原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
<li>时间复杂度:平均情况：O（nlog2n）  最好情况：O（nlog2n） 最坏情况：O（n2）</li>
<li>空间复杂度：O（nlog2n）</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function quickSort(arr,l,r)&#123;</div><div class="line">	if(l &lt; r)&#123;</div><div class="line">		var i = l, j = r, x = arr[i];</div><div class="line">		while(i&lt;j)&#123;</div><div class="line">			while(i&lt;j &amp;&amp; arr[j]&gt;x)</div><div class="line">				j--;</div><div class="line">			</div><div class="line">			if(i&lt;j)</div><div class="line">				//这里用i++，被换过来的必然比x小，赋值后直接让i自加，不用再比较，可以提高效率</div><div class="line">				arr[i++] = arr[j];</div><div class="line">			</div><div class="line">			while(i&lt;j &amp;&amp; arr[i]&lt;x)</div><div class="line">				i++;</div><div class="line">			</div><div class="line">			if(i&lt;j)</div><div class="line">				//这里用j--，被换过来的必然比x大，赋值后直接让j自减，不用再比较，可以提高效率</div><div class="line">				arr[j--] = arr[i];</div><div class="line">		&#125;</div><div class="line">		arr[i] = x;</div><div class="line">		</div><div class="line">		quickSort(arr, l, i-1);</div><div class="line">		quickSort(arr, i+1, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h2><ul>
<li>原理：将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。             比冒泡法和选择排序的性能要更好一些</li>
<li>时间复杂度：平均情况：O（n2）  最好情况：O（n） 最坏情况：O（n2）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：稳定</li>
</ul>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<p><img src="http://my.csdn.net/uploads/201207/17/1342520948_8667.jpg" alt="image"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var array = [23,0,32,45,56,75,43,0,34];</div><div class="line">for(var j = 0;j &lt; array.length;j++) &#123;</div><div class="line"> var key = array[j];</div><div class="line"> var i = j - 1;</div><div class="line"> while (i &gt; -1 &amp;&amp; array[i] &gt; key)</div><div class="line"> &#123;</div><div class="line">  array[i + 1] = array[i];</div><div class="line">  i = i - 1;</div><div class="line"> &#125;</div><div class="line"> array[i + 1] = key;</div><div class="line">&#125;</div><div class="line">console.log(array);</div></pre></td></tr></table></figure></p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><ul>
<li>原理：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。。</li>
<li>时间复杂度:平均情况：O(n√n)  最好情况：O（nlog2n） 最坏情况：O（n2）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：不稳定 </li>
</ul>
<p><strong>操作方法</strong>：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><img src="http://my.csdn.net/uploads/201207/18/1342577299_5077.jpg" alt="image"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">23</span>,<span class="number">0</span>,<span class="number">32</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">75</span>,<span class="number">43</span>,<span class="number">0</span>,<span class="number">34</span>];</div><div class="line"><span class="keyword">var</span> shellSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">var</span> length=arr.length;</div><div class="line">  <span class="keyword">var</span> h=<span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(h&lt;length/<span class="number">3</span>)</div><div class="line">  &#123;</div><div class="line">    h=<span class="number">3</span>*h+<span class="number">1</span>;<span class="comment">//设置间隔</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=h; i&lt;length; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i; j&gt;=h &amp;&amp; arr[j]&lt;arr[j-h]; j-=h)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">var</span> temp =arr[j-h];</div><div class="line">        arr[j-h]=arr[j];</div><div class="line">        arr[j]=temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    h=(h<span class="number">-1</span>)/<span class="number">3</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> newArray = shellSort(array);</div><div class="line"><span class="built_in">console</span>.log(newArray);</div></pre></td></tr></table></figure></p>
<h2 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="5.简单选择排序"></a>5.简单选择排序</h2><ul>
<li>原理：通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1&lt;=i&lt;=n)个记录交换         简单选择排序的性能要略优于冒泡排序</li>
<li>时间复杂度:平均情况：O（n2）  最好情况：O（n） 最坏情况：O（n2）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var array = [23,0,32,45,56,75,43,0,34];</div><div class="line"> </div><div class="line">for(var i = 0; i &lt; array.length - 1; i++)</div><div class="line">&#123;</div><div class="line"> var pos = i;</div><div class="line"> for(var j = i + 1; j &lt; array.length;j++)</div><div class="line"> &#123;</div><div class="line">  if(array[j] &lt; array[pos])</div><div class="line">  &#123;</div><div class="line">   pos=j;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> var temp=array[i];</div><div class="line"> array[i]=array[pos];</div><div class="line"> array[pos]=temp;</div><div class="line">&#125;</div><div class="line">console.log(array);</div></pre></td></tr></table></figure>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h2><ul>
<li>原理：堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶 的根结点.将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了</li>
<li>时间复杂度：平均情况：O(nlog2n)  最好情况：O（nlog2n） 最坏情况：O（nlog2n）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：不稳定 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var array = [23,0,32,45,56,75,43,0,34];</div><div class="line">function heapSort(array)</div><div class="line">&#123;</div><div class="line">  for (var i = Math.floor(array.length / 2); i &gt;= 0; i--)</div><div class="line">  &#123;</div><div class="line">    heapAdjust(array, i, array.length - 1); //将数组array构建成一个大顶堆</div><div class="line">  &#125;</div><div class="line">  for (i = array.length - 1; i &gt;= 0; i--)</div><div class="line">  &#123;</div><div class="line">    /*把根节点交换出去*/</div><div class="line">    var temp = array[i];</div><div class="line">    array[i] = array[0];</div><div class="line">    array[0] = temp;</div><div class="line">    /*余下的数组继续构建成大顶堆*/</div><div class="line">    heapAdjust(array, 0, i - 1);</div><div class="line">  &#125;</div><div class="line">  return array;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">function heapAdjust(array, start, max)</div><div class="line">&#123;</div><div class="line">  var temp = array[start];//temp是根节点的值</div><div class="line">  for (var j = 2 * start; j &lt; max; j *= 2)</div><div class="line">  &#123;</div><div class="line">    if (j &lt; max &amp;&amp; array[j] &lt; array[j + 1])</div><div class="line">    &#123; //取得较大孩子的下标</div><div class="line">      ++j;</div><div class="line">    &#125;</div><div class="line">    if (temp &gt;= array[j])</div><div class="line">      break;</div><div class="line">    array[start] = array[j];</div><div class="line">    start = j;</div><div class="line">  &#125;</div><div class="line">  array[start] = temp;</div><div class="line">&#125;</div><div class="line">var newArray = heapSort(array);</div><div class="line">console.log(newArray);</div></pre></td></tr></table></figure>
<h2 id="7-二路归并"><a href="#7-二路归并" class="headerlink" title="7.二路归并"></a>7.二路归并</h2><ul>
<li>原理：假设初始序列含有n个记录,则可以看成n个有序的子序列,每个子序列的长度为1,然后两两归并,得到(不小于n/2的最小整数)个长度为2或1的有序子序列,再两两归并,…如此重复,直至得到一个长度为n的有序序列为止　　　</li>
<li>时间复杂度:平均情况：O(nlog2n)  最好情况：O（nlog2n） 最坏情况：O（nlog2n）</li>
<li>空间复杂度：O（1）</li>
<li>稳定性：稳定</li>
</ul>
<p>将两个按值有序序列合并成一个按值有序序列，则称之为二路归并排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function merge(left, right) &#123;</div><div class="line">    var result = [],</div><div class="line">        il = 0,</div><div class="line">        ir = 0;</div><div class="line"></div><div class="line">    while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;</div><div class="line">        if (left[il] &lt; right[ir]) &#123;</div><div class="line">            result.push(left[il++]);</div><div class="line">        &#125; else &#123;</div><div class="line">            result.push(right[ir++]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while(left[il])&#123;</div><div class="line">        result.push(left[il++]);</div><div class="line">	&#125;</div><div class="line">    while(right[ir])&#123;</div><div class="line">        result.push(right[ir++]);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h2><ul>
<li>原理：将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。　　</li>
<li>时间复杂度：平均情况：O(d(r+n))  最好情况：O（d(n+rd)） 最坏情况：O（d(r+n)）   r:关键字的基数   d:长度  n:关键字个数</li>
<li>空间复杂度：O（rd+n）</li>
<li>稳定性：稳定 </li>
</ul>
<h2 id="9-排序总结"><a href="#9-排序总结" class="headerlink" title="9.排序总结"></a>9.排序总结</h2><p><img src="http://my.csdn.net/uploads/201207/19/1342700879_2982.jpg" alt="image"></p>
<p><img src="http://my.csdn.net/uploads/201207/21/1342856655_3698.jpg" alt="image"><br><strong>说明：</strong></p>
<ul>
<li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li>
<li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li>
<li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li>
<li><strong>稳定性：</strong></li>
<li>排序算法的稳定性: 若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。</li>
<li>稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较； </li>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li>
</ul>
<h2 id="10-选择排序算法准则"><a href="#10-选择排序算法准则" class="headerlink" title="10.选择排序算法准则"></a>10.选择排序算法准则</h2><p>每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。<br>一般而言，需要考虑的因素有以下四点：</p>
<ol>
<li>待排序的记录数目n的大小；</li>
<li>记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</li>
<li>关键字的结构及其分布情况；</li>
<li>对排序稳定性的要求。</li>
</ol>
<p><strong>设待排序元素的个数为n</strong>:</p>
<ol>
<li>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</li>
</ol>
<ul>
<li>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</li>
<li>堆排序 ：  如果内存空间允许且要求稳定性的，</li>
<li>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</li>
</ul>
<ol>
<li>当n较大，内存空间允许，且要求稳定性 =》归并排序</li>
<li>当n较小，可采用直接插入或直接选择排序。<br> 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。<br> 直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</li>
<li>一般不使用或不直接使用传统的冒泡排序。</li>
<li>基数排序</li>
</ol>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><p>二分查找又称折半查找，是在有序数组查找中用到的较为频繁的一种算法，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。</p>
<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function binary_search(arr, key) &#123;</div><div class="line">    var low = 0,</div><div class="line">        high = arr.length - 1;</div><div class="line">    while(low &lt;= high)&#123;</div><div class="line">        var mid = parseInt((high + low) / 2);</div><div class="line">        if(key == arr[mid])&#123;</div><div class="line">            return  mid;</div><div class="line">        &#125;else if(key &gt; arr[mid])&#123;</div><div class="line">            low = mid + 1;</div><div class="line">        &#125;else if(key &lt; arr[mid])&#123;</div><div class="line">            high = mid -1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function binary_search2(arr, low, high, key) &#123;</div><div class="line">	if(low &gt; high)</div><div class="line">	    return -1;</div><div class="line">	var mid = parseInt((low + high)/2);</div><div class="line">	if(key == arr[mid])</div><div class="line">	    return mid;</div><div class="line">	else if(key &gt; arr[mid])</div><div class="line">	    return binary_search2(arr, mid+1, high, key);</div><div class="line">	else if(key &lt; arr[mid])</div><div class="line">        return binary_search2(arr, low, mid-1, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据结构&amp;算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5新特性]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/HTM5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h1><p><strong>兼容问题</strong>：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签</p>
<h2 id="1-绘画-canvas-元素"><a href="#1-绘画-canvas-元素" class="headerlink" title="1. 绘画 canvas 元素"></a>1. 绘画 canvas 元素</h2><h2 id="2-媒介回放的-video-和-audio-元素"><a href="#2-媒介回放的-video-和-audio-元素" class="headerlink" title="2.媒介回放的 video 和 audio 元素"></a>2.媒介回放的 video 和 audio 元素</h2><p> HTML5 规定了在网页上嵌入音频元素的标准，即使用 <audio> 元素。</audio></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;audiocontrols&gt;</div><div class="line">&lt;sourcesrc=&quot;horse.ogg&quot;type=&quot;audio/ogg&quot;&gt;</div><div class="line">&lt;sourcesrc=&quot;horse.mp3&quot;type=&quot;audio/mpeg&quot;&gt;</div><div class="line">您的浏览器不支持 audio 元素。</div><div class="line">&lt;/audio&gt;</div></pre></td></tr></table></figure>
<p> HTML5 规定了一种通过 video 元素来包含视频的标准方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;videowidth=&quot;320&quot;height=&quot;240&quot;controls&gt;</div><div class="line">&lt;sourcesrc=&quot;movie.mp4&quot;type=&quot;video/mp4&quot;&gt;</div><div class="line">&lt;sourcesrc=&quot;movie.ogg&quot;type=&quot;video/ogg&quot;&gt;</div><div class="line">您的浏览器不支持Video标签。</div><div class="line">&lt;/video&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="3-本地离线存储"><a href="#3-本地离线存储" class="headerlink" title="3.本地离线存储"></a>3.本地离线存储</h2><p> Web Storage DOMAPI为Web应用提供了一个能够替代cookie的Javascript解决方案</p>
<ul>
<li>localStorage长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除<h2 id="4-语意化更好的内容元素"><a href="#4-语意化更好的内容元素" class="headerlink" title="4.语意化更好的内容元素"></a>4.语意化更好的内容元素</h2></li>
<li><header></header></li>
<li><nav></nav></li>
<li><section></section></li>
<li><article></article></li>
<li><aside></aside></li>
<li><figcaption></figcaption></li>
<li><figure></figure></li>
<li><footer><h2 id="5-表单控件"><a href="#5-表单控件" class="headerlink" title="5.表单控件"></a>5.表单控件</h2>HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。<br>calendar、date、time、email、url、search</footer></li>
</ul>
<h2 id="6-HTML5-拖放"><a href="#6-HTML5-拖放" class="headerlink" title="6.HTML5 拖放"></a>6.HTML5 拖放</h2><p>为了使元素可拖动，把 draggable 属性设置为 true</p>
<h2 id="7-HTML5-离线Web应用（应用程序缓存）"><a href="#7-HTML5-离线Web应用（应用程序缓存）" class="headerlink" title="7.HTML5 离线Web应用（应用程序缓存）"></a>7.HTML5 离线Web应用（应用程序缓存）</h2><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。<br>应用程序缓存为应用带来三个优势：</p>
<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<p>HTML5 Cache Manifest 实例<br>下面的例子展示了带有 cache manifest 的 HTML 文档（供离线浏览）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;htmlmanifest=&quot;demo.appcache&quot;&gt;</div><div class="line">&lt;body&gt;</div><div class="line">The content of the document......</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>Manifest 文件</strong></p>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。<br>manifest 文件可分为三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面</li>
</ul>
<h2 id="8-HTML5-WebSocket"><a href="#8-HTML5-WebSocket" class="headerlink" title="8.HTML5 WebSocket"></a>8.HTML5 WebSocket</h2><p>WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。</p>
]]></content>
      
        <categories>
            
            <category> HTML5&amp;CSS3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3新特性]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h1><h2 id="1-CSS3选择器"><a href="#1-CSS3选择器" class="headerlink" title="1.CSS3选择器"></a>1.CSS3选择器</h2><p><strong>属性选择器：</strong></p>
<ul>
<li>E[attr] 只要有属性名</li>
<li>E[attr=value] 属性名=属性值</li>
<li>E[attr~=blue] 包含这个blue整个单词就可以</li>
<li>E[attr^=c] 以这个字母c开头的</li>
<li>E[attr$=b] 以这个字母b结尾的</li>
<li>E[attr*=a] 只要包含a这个字母就行</li>
<li>E[attr|=z] 只要以字母z-开头的或者就是字母z的</li>
</ul>
<p><strong>结构性伪类选择器</strong>：</p>
<ul>
<li>E:nth-child(n) 第n个子节点</li>
<li>div:nth-child(odd) 奇数行</li>
<li>div:nth-child(even) 偶数行</li>
<li>div:nth-child(2n) 2的倍数</li>
<li>E:nth-last-child(n) 倒数第n个</li>
</ul>
<p><strong>其他</strong>：</p>
<ul>
<li>E:empty 空元素</li>
<li>E:first-child 第一个子节点、和 E:nth-child(1)等价</li>
<li>E:last-child 倒数第一个、和 E:nth-last-child(1)等价</li>
<li><ul>
<li>注意不能有其他兄弟节点</li>
</ul>
</li>
<li></li>
<li>E:target 锚点元素的样式</li>
<li>div:target{width:100px;}</li>
<li><div id="”div1″"></div></li>
<li>只要锚点有#div1那上面的target样式就会生效</li>
<li>E:disabled 表单元素设置disabled</li>
<li>E:enabled 可点击的表单元素</li>
<li>E:checked 表示已经选中的checkbox或者radio</li>
<li></li>
<li>文本新增伪类：</li>
<li>E:first-line 第一行</li>
<li>E:first-letter 第一个字</li>
<li>E::selection 选中文本的时候</li>
<li>E::before E标签前面添加东西,需要配合content来用</li>
<li></li>
<li>E::after E标签后面添加东西</li>
<li>E:before E:after单引号也能用</li>
<li>E:not(s) 不包括s</li>
<li>h1:not(.red) 排除有class为red的h1元素</li>
<li>E~F E后面的F兄弟节点<a id="more"></a>
<h2 id="2-CSS3-边框（Borders）"><a href="#2-CSS3-边框（Borders）" class="headerlink" title="2.CSS3 边框（Borders）"></a>2.CSS3 边框（Borders）</h2>用CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序</li>
<li>border-image    设置所有边框图像的速记属性。</li>
<li>border-radius    一个用于设置所有四个边框- *-半径属性的速记属性</li>
<li>box-shadow    附加一个或多个下拉框的阴影</li>
</ul>
<h2 id="3-CSS3-背景"><a href="#3-CSS3-背景" class="headerlink" title="3.CSS3 背景"></a>3.CSS3 背景</h2><ul>
<li>background-clip    规定背景的绘制区域。</li>
<li>background-origin    规定背景图片的定位区域。</li>
<li>background-size    规定背景图片的尺寸</li>
</ul>
<h2 id="4-CSS3-渐变"><a href="#4-CSS3-渐变" class="headerlink" title="4.CSS3 渐变"></a>4.CSS3 渐变</h2><p>CSS3 定义了两种类型的渐变（gradients）：</p>
<ul>
<li>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(direction, color-stop1, color-stop2,...);</div></pre></td></tr></table></figure>
<ul>
<li>径向渐变（Radial Gradients）- 由它们的中心定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background: radial-gradient(center, shape size, start-color,...,last-color);</div></pre></td></tr></table></figure>
<h2 id="5-CSS3-文本效果"><a href="#5-CSS3-文本效果" class="headerlink" title="5.CSS3 文本效果"></a>5.CSS3 文本效果</h2><ul>
<li>text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。</li>
<li>text-justify    规定当 text-align 设置为 “justify” 时所使用的对齐方法。</li>
<li>text-outline    规定文本的轮廓。</li>
<li>text-overflow    规定当文本溢出包含元素时发生的事情。</li>
<li>text-shadow    向文本添加阴影。</li>
<li>text-wrap    规定文本的换行规则。</li>
</ul>
<h2 id="6-CSS3-转换和变形"><a href="#6-CSS3-转换和变形" class="headerlink" title="6.CSS3 转换和变形"></a>6.CSS3 转换和变形</h2><p>  旋转（transform）<br>  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</p>
<h2 id="7-CSS3-盒模型"><a href="#7-CSS3-盒模型" class="headerlink" title="7.CSS3 盒模型"></a>7.CSS3 盒模型</h2><p> 在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：</p>
<ul>
<li>resize：none | both | horizontal | vertical | inherit <em>resize属性指定一个元素是否应该由用户去调整大小。</em></li>
<li>box-sizing: content-box | border-box | inherit box-sizing <em>属性允许您以确切的方式定义适应某个区域的具体内容</em></li>
<li>outline:outline-color outline-style outline-width outine-offset<br><em>outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</em></li>
</ul>
<h2 id="8-CSS3-弹性盒flexbox"><a href="#8-CSS3-弹性盒flexbox" class="headerlink" title="8.CSS3 弹性盒flexbox"></a>8.CSS3 弹性盒flexbox</h2><ul>
<li>display    指定 HTML 元素盒子类型。</li>
<li>flex-direction    指定了弹性容器中子元素的排列方式</li>
<li>justify-content    设置弹性盒子元素在主轴（横轴）方向上的对齐方式</li>
<li>align-items    设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式</li>
<li>flex-wrap    设置弹性盒子的子元素超出父容器时是否换行</li>
<li>align-content    修改 flex-wrap 属性的行为，类似 align-items,但不是设置子元素对齐，而是设置行对齐</li>
<li>flex-flow    flex-direction 和 flex-wrap 的简写</li>
<li>order    设置弹性盒子的子元素排列顺序</li>
<li>align-self    在弹性子元素上使用。覆盖容器的 align-items 属性</li>
<li>flex    设置弹性盒子的子元素如何分配空间</li>
</ul>
<h2 id="9-多媒体查询"><a href="#9-多媒体查询" class="headerlink" title="9.多媒体查询"></a>9.多媒体查询</h2><ol>
<li>使用媒体类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;site.css&quot;media=&quot;screen&quot;/&gt;</div><div class="line">&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;print.css&quot;media=&quot;print&quot;/&gt;</div></pre></td></tr></table></figure>
<ol>
<li>媒体查询规则</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media all and(min-width:800px)&#123;...&#125;</div></pre></td></tr></table></figure>
<p>@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。<br>(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。</p>
<ol>
<li>and 条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media(min-width:800px)and(max-width:1200px)and(orientation:portrait)&#123;...&#125;</div></pre></td></tr></table></figure>
<ol>
<li>or 关键词</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media(min-width:800px)or(orientation:portrait)&#123;...&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用 not</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media(not min-width:800px)&#123;...&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> HTML5&amp;CSS3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[websocket学习]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/websocket%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="1-WebSocket-前世今生"><a href="#1-WebSocket-前世今生" class="headerlink" title="1.WebSocket 前世今生"></a>1.WebSocket 前世今生</h1><p>众所周知，Web应用的交互过程通常是客户端通过浏览器发出一个请求，服务器端接收请求后进行处理并返回结果给客户端，客户端浏览器将信息呈现。</p>
<p>这种机制对于信息变化不是特别频繁的应用尚可，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在当前业界移动互联网蓬勃发展的趋势下，高并发与用户实时响应是 Web 应用经常面临的问题，比如金融证券的实时信息，Web 导航应用中的地理位置获取，社交网络的实时消息推送等。</p>
<p>传统的请求-响应模式的Web开发在处理此类业务场景时，通常采用实时通讯方案，常见的是：</p>
<ul>
<li>轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。</li>
<li>基于 Flash，AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用Flash暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，且因为Flash安装率高，应用场景比较广泛，但在移动互联网终端上 Flash的支持并不好。IOS 系统中没有 Flash 的存在，在 Android 中虽然有 Flash 的支持，但实际的使用效果差强人意，且对移动设备的硬件配置要求较高。2012年Adobe官方宣布不再支持 Android4.1+系统，宣告了Flash在移动终端上的死亡。</li>
</ul>
<p>从上文可以看出，传统Web模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。<br><a id="more"></a></p>
<h1 id="2-WebSocket-机制"><a href="#2-WebSocket-机制" class="headerlink" title="2.WebSocket 机制"></a>2.WebSocket 机制</h1><p>WebSocket 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP来传输数据，但是它==和HTTP最大不同==是：</p>
<ul>
<li>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；</li>
<li>WebSocket 需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。<h2 id="连接模式"><a href="#连接模式" class="headerlink" title="连接模式"></a>连接模式</h2>传统 HTTP 请求响应客户端服务器交互图：</li>
</ul>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img001.jpg" alt="image"></p>
<p>使用 WebSocket 模式客户端与服务器的交互如下图：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img002.jpg" alt="image"></p>
<p>上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似 Socket 的 TCP长连接的通讯模式，一旦WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>
<h2 id="交互报文"><a href="#交互报文" class="headerlink" title="交互报文"></a>交互报文</h2><p>在客户端，new WebSocket 实例化一个新的 WebSocket 客户端对象，连接类似 ws://yourdomain:port/path 的服务端 WebSocket URL，WebSocket 客户端对象会自动解析并识别为 WebSocket 请求，从而连接服务端端口，执行双方握手过程，客户端发送数据格式类似：</p>
<p><strong>WebSocket 客户端连接报文：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /webfin/websocket/ HTTP/1.1</div><div class="line">Host: localhost</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==</div><div class="line">Origin: &lt;a href=&quot;http://localhost/&quot;&gt;&lt;code&gt;http://localhost&lt;/code&gt;&lt;/a&gt;:8080</div><div class="line">Sec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>可以看到，客户端发起的 WebSocket 连接报文类似传统 HTTP 报文，”Upgrade：websocket”参数值表明这是 WebSocket 类型请求，“Sec-WebSocket-Key”是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept”应答，否则客户端会抛出“Error during WebSocket handshake”错误，并关闭连接。</p>
<p><strong>WebSocket 服务端响应报文</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=</div></pre></td></tr></table></figure>
<p>“Sec-WebSocket-Accept”的值是服务端采用与客户端一致的密钥计算出来后返回客户端的,“HTTP/1.1 101 Switching Protocols”表示服务端接受 WebSocket 协议的客户端连接，经过这样的请求-响应处理后，客户端服务端的 WebSocket 连接握手成功, 后续就可以进行 TCP 通讯了。读者可以查阅WebSocket 协议栈了解 WebSocket 客户端和服务端更详细的交互数据格式。<br>在开发方面，WebSocket API 也十分简单，我们只需要实例化 WebSocket，创建连接，然后服务端和客户端就可以相互发送和响应消息，在下文 WebSocket 实现及案例分析部分，可以看到详细的 WebSocket API 及代码实现。</p>
<h1 id="3-WebSocket-实现"><a href="#3-WebSocket-实现" class="headerlink" title="3.WebSocket 实现"></a>3.WebSocket 实现</h1><p>WebSocket 的实现分为客户端和服务端两部分，客户端（通常为浏览器）发出WebSocket连接请求，服务端响应，实现类似TCP握手的动作，从而在浏览器客户端和 WebSocket服务端之间形成一条HTTP长连接快速通道。两者之间后续进行直接的数据互相传送，不再需要发起连接和相应。</p>
<h2 id="WebSocket-服务端-API"><a href="#WebSocket-服务端-API" class="headerlink" title="WebSocket 服务端 API"></a>WebSocket 服务端 API</h2><h2 id="WebSocket-客户端-API"><a href="#WebSocket-客户端-API" class="headerlink" title="WebSocket 客户端 API"></a>WebSocket 客户端 API</h2><p>客户端 WebSocketAPI基本上已经在各个主流浏览器厂商中实现了统一，因此使用标准 HTML5 定义的 WebSocket 客户端的 JavaScript API 即可，当然也可以使用业界满足 WebSocket 标准规范的开源框架，如 Socket.io。</p>
<p><strong>WebSocket 客户端 API 示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ws = new WebSocket(“ws://echo.websocket.org”); </div><div class="line"> ws.onopen = function()&#123;ws.send(“Test!”); &#125;; </div><div class="line"> ws.onmessage = function(evt)&#123;console.log(evt.data);ws.close();&#125;; </div><div class="line"> ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;; </div><div class="line"> ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>第一行代码是在申请一个WebSocket对象，参数是需要连接的服务器端的地址，同 HTTP 协议开头一样，WebSocket 协议的 URL 使用 ws://开头，另外安全的 WebSocket 协议使用 wss://开头。</li>
<li>第二行到第五行为WebSocket对象注册消息的处理函数，WebSocket 对象一共支持四个消息 onopen, onmessage, onclose 和 onerror，有了这 4 个事件，我们就可以很容易很轻松的驾驭 WebSocket。</li>
<li>当 Browser 和 WebSocketServer 连接成功后，会触发 onopen 消息；如果连接失败，发送、接收数据失败或者处理数据出现错误，browser 会触发 onerror 消息；当 Browser 接收到 WebSocketServer 发送过来的数据时，就会触发 onmessage 消息，参数 evt 中包含 Server 传输过来的数据；当 Browser 接收到 WebSocketServer 端发送的关闭连接请求时，就会触发 onclose 消息。我们可以看出所有的操作都是采用异步回调的方式触发，这样不会阻塞UI，可以获得更快的响应时间，更好的用户体验。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[观察者模式 (订阅者与发布者)]]></title>
      <url>https://barryleeweb.github.io/2017/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%20(%E8%AE%A2%E9%98%85%E8%80%85%E4%B8%8E%E5%8F%91%E5%B8%83%E8%80%85)/</url>
      <content type="html"><![CDATA[<h2 id="理解观察者模式："><a href="#理解观察者模式：" class="headerlink" title="理解观察者模式："></a>理解观察者模式：</h2><p>什么是观察者模式？</p>
<p>观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。<br><a id="more"></a><br>理解观察者模式：</p>
<p>JS传统事件就是一个观察者模式，之所以要有观察者模式，是因为有时候和传统事件无关的事件，比如：2个或者更多模块的直接通信问题，比如说我有个index.html页面，我有很多JS文件，比如：</p>
<p>a.js: function a(){};    b.js: function b(){};  c.js  function c(){};  等等。后面还有许多这样的JS， 那么我要在index.html初始化这些函数的话，我需要这样调用a();b();c()等等，也就是说页面调用的时候 我要这样调用，增加了依赖性，我要知道有多少个函数要这样初始化调用，但是如果我们现在用观察者模式就不需要知道有哪些订阅者，比如一个模块(或者多个模块)订阅了一个主题(或者事件)，另一个模块发布这个主题时候，订阅这个主题模块就可以执行了，观察者主要让订阅者与发布者解耦，发布者不需要知道哪些模块订阅了这个主题，它只管发布这个主题就可以了，同样订阅者也无需知道那个模块会发布这个主题，它只管订阅这个主题就可以了。这样2个模块(或更多模块)就实现了关联了。而不需要和上面代码一样，我要知道哪些模块要初始化，我要怎样初始化。这只是一个简单的列子解释观察者模式要使用在什么地方，我也看过很多博客关于这方面的资料，但是很多人写博客只是讲了如何实现观察者模式及观察者模式的好处，并没有讲我们什么时候该使用观察者模式，所以我列举了上面的列子，就是多个不同业务模块需要相互关联的时候，可以使用观察者模式。就好比requireJS，seaJS，KISSY解决依赖的问题一样(比如A依赖于B，B依赖于C，只要一个解决入口文件，其他都会异步加载出来一样)。也就是说各个模块之间的关联性可以使用观察者模式来设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">	&lt;title&gt;PubSub&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	function PubSub() &#123;</div><div class="line">	    this.handlers = &#123;&#125;;</div><div class="line">	&#125;</div><div class="line">	PubSub.prototype = &#123;</div><div class="line">	    // 订阅事件</div><div class="line">	    on: function(eventType,handler)&#123;</div><div class="line">	        var self = this;</div><div class="line">	        if(!(eventType in self.handlers)) &#123;</div><div class="line">	             self.handlers[eventType] = [];</div><div class="line">	        &#125;</div><div class="line">	        self.handlers[eventType].push(handler);  // 对象handlers存储key：事件名handlers及value：函数handler</div><div class="line">	        return this;</div><div class="line">	    &#125;,</div><div class="line">        // 触发事件(发布事件)</div><div class="line">        emit: function(eventType)&#123;</div><div class="line">           var self = this;</div><div class="line">           var handlerArgs = Array.prototype.slice.call(arguments,1);  // 取第二个开始的参数</div><div class="line">           for(var i = 0; i &lt; self.handlers[eventType].length; i++) &#123;  // 遍历事件名的所有回调函数</div><div class="line">                 self.handlers[eventType][i].apply(self,handlerArgs);   // 将参数传入回调函数</div><div class="line">           &#125;</div><div class="line">           return self;</div><div class="line">        &#125;</div><div class="line">	&#125;;</div><div class="line">	// 调用方式如下：</div><div class="line"></div><div class="line">	var pubsub = new PubSub();</div><div class="line"></div><div class="line">	pubsub.on(&apos;A&apos;,function(data)&#123;</div><div class="line"></div><div class="line">	console.log(1 + data);  // 执行第一个回调业务函数</div><div class="line"></div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	pubsub.on(&apos;A&apos;,function(data)&#123;</div><div class="line"></div><div class="line">	console.log(2 + data); // 执行第二个业务回调函数</div><div class="line"></div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	// 触发事件A</div><div class="line"></div><div class="line">	pubsub.emit(&apos;A&apos;,&quot;我是参数&quot;);</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Javascript设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[baidu_ife_小薇学院总结（四）]]></title>
      <url>https://barryleeweb.github.io/2017/07/25/baidu_ife_%E5%B0%8F%E8%96%87%E5%AD%A6%E9%99%A2%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Task8-响应式网格（栅格化）"><a href="#Task8-响应式网格（栅格化）" class="headerlink" title="Task8:响应式网格（栅格化）"></a>Task8:响应式网格（栅格化）</h1><h2 id="1-目标："><a href="#1-目标：" class="headerlink" title="1.目标："></a>1.目标：</h2><p><strong>使用 HTML 与 CSS 实现类似 BootStrap 的响应式 12 栏网格布局，根据屏幕宽度，元素占的栏数不同。</strong></p>
<h2 id="2-参考链接"><a href="#2-参考链接" class="headerlink" title="2.参考链接"></a>2.参考链接</h2><p><a href="http://j4n.co/blog/Creating-your-own-css-grid-system" target="_blank" rel="external">Creating Your Own CSS Grid System</a></p>
<p><strong>栅格化设计：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;IFE JavaScript Task 07&lt;/title&gt;</div><div class="line">    &lt;style type=&quot;text/css&quot;&gt;</div><div class="line">     *&#123;margin: 0px;padding: 0px;&#125;</div><div class="line">      </div><div class="line">      /*-- http://j4n.co/blog/Creating-your-own-css-grid-system  栅格化设计-- */ </div><div class="line"></div><div class="line">      /*-- The Container -- */ </div><div class="line">      .grid-container&#123;</div><div class="line">          width: 100%; </div><div class="line">          max-width: 1200px;   </div><div class="line">      &#125;</div><div class="line"></div><div class="line">      /*-- The Row -- */ </div><div class="line">      /*-- our cleafix hack -- */ </div><div class="line">      .row:before, </div><div class="line">      .row:after &#123;</div><div class="line">          content:&quot;&quot;;</div><div class="line">          display: table ;</div><div class="line">          clear:both;</div><div class="line">      &#125;</div><div class="line">       </div><div class="line">      /*-- The Column , Column Positioning , Column Widths , Column Gutters -- */ </div><div class="line">      .grid-container *&#123;</div><div class="line">          box-sizing: border-box;  /*-- setting border box on all elements inside the grid --*/</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      [class*=&apos;col-&apos;] &#123; /* a[src*=&quot;abc&quot;] 选择其 src 属性中包含 &quot;abc&quot; 子串的每个 &lt;a&gt; 元素。*/</div><div class="line">          float: left; </div><div class="line">          min-height: 1px; </div><div class="line">          width: 16.66%; </div><div class="line">          /*-- Column gutter -- */</div><div class="line">          padding: 12px; </div><div class="line">          background-color: #FFDCDC;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      .col-1&#123; width: 16.66%; &#125;</div><div class="line">      .col-2&#123; width: 33.33%; &#125;</div><div class="line">      .col-3&#123; width: 50%;    &#125;</div><div class="line">      .col-4&#123; width: 66.66%; &#125;</div><div class="line">      .col-5&#123; width: 83.33%; &#125;</div><div class="line">      .col-6&#123; width: 100%;   &#125;</div><div class="line"></div><div class="line">      .outline, .outline *&#123;</div><div class="line">          outline: 1px solid #F6A1A1; </div><div class="line">      &#125;</div><div class="line"></div><div class="line">      /*-- some extra column content styling --*/</div><div class="line">      [class*=&apos;col-&apos;] &gt; p &#123;</div><div class="line">       background-color: #FFC2C2; </div><div class="line">       padding: 0;</div><div class="line">       margin: 0;</div><div class="line">       text-align: center; </div><div class="line">       color: white; </div><div class="line">      &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;grid-container outline&quot;&gt;</div><div class="line">        &lt;div class=&quot;row&quot;&gt;</div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-1&quot;&gt;&lt;p&gt;col-1&lt;/p&gt;&lt;/div&gt; </div><div class="line">        &lt;/div&gt; </div><div class="line">        &lt;div class=&quot;row&quot;&gt;</div><div class="line">            &lt;div class=&quot;col-2&quot;&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-2&quot;&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-2&quot;&gt;&lt;p&gt;col-2&lt;/p&gt;&lt;/div&gt; </div><div class="line">        &lt;/div&gt; </div><div class="line">        &lt;div class=&quot;row&quot;&gt;</div><div class="line">            &lt;div class=&quot;col-3&quot;&gt;&lt;p&gt;col-3&lt;/p&gt;&lt;/div&gt; </div><div class="line">            &lt;div class=&quot;col-3&quot;&gt;&lt;p&gt;col-3&lt;/p&gt;&lt;/div&gt; </div><div class="line">        &lt;/div&gt; </div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>移动端响应式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/*screens under 800px*/</div><div class="line">@media all and (max-width:800px)&#123;</div><div class="line">    .col-1&#123; width: 33.33%;    &#125;</div><div class="line">    .col-2&#123; width: 50%;        &#125;</div><div class="line">    .col-3&#123; width: 83.33%;    &#125;</div><div class="line">    .col-4&#123; width: 100%;    &#125;</div><div class="line">    .col-5&#123; width: 100%;    &#125;</div><div class="line">    .col-6&#123; width: 100%;      &#125;</div><div class="line"></div><div class="line">    .row .col-2:last-of-type&#123; /* p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。*/</div><div class="line">        width: 100%; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .row .col-5 ~ .col-1&#123;  /*p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。相同的父元素,但是 element2 不必直接紧随 element1*/</div><div class="line">        width: 100%; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/*screens under 650px*/</div><div class="line">@media all and (max-width:650px)&#123;</div><div class="line">    .col-1&#123; width: 50%;        &#125;</div><div class="line">    .col-2&#123; width: 100%;    &#125;</div><div class="line">    .col-3&#123; width: 100%;    &#125;</div><div class="line">    .col-4&#123; width: 100%;    &#125;</div><div class="line">    .col-5&#123; width: 100%;    &#125;</div><div class="line">    .col-6&#123; width: 100%;      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-响应式-12-栏网格布局"><a href="#3-响应式-12-栏网格布局" class="headerlink" title="3.响应式 12 栏网格布局"></a>3.响应式 12 栏网格布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@media all and (min-width:769px)&#123;</div><div class="line">	.col-md-1&#123; width: 8.33%; &#125;</div><div class="line">	.col-md-2&#123; width: 16.66%; &#125;</div><div class="line">	.col-md-3&#123; width: 25%;    &#125;</div><div class="line">	.col-md-4&#123; width: 33.33%; &#125;</div><div class="line">	.col-md-6&#123; width: 50%;   &#125;</div><div class="line">&#125;</div><div class="line">/*screens under 800px*/</div><div class="line">@media all and (max-width:768px)&#123;</div><div class="line">  .col-sm-2&#123; width: 16.66%;   &#125;</div><div class="line">  .col-sm-3&#123; width: 25%;      &#125;</div><div class="line">  .col-sm-6&#123; width: 50%;      &#125;</div><div class="line">  .col-sm-8&#123; width: 66.66%;   &#125;</div><div class="line">  .col-sm-12&#123; width: 100%;    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Task10-Flexbox-布局练习"><a href="#Task10-Flexbox-布局练习" class="headerlink" title="Task10:Flexbox 布局练习"></a>Task10:Flexbox 布局练习</h1><p><img src="http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png" alt="image"></p>
<h2 id="1-Flex布局是什么？"><a href="#1-Flex布局是什么？" class="headerlink" title="1.Flex布局是什么？"></a>1.Flex布局是什么？</h2><p>W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构</p>
<h2 id="2-Flexbox布局和网格布局的异同"><a href="#2-Flexbox布局和网格布局的异同" class="headerlink" title="2.Flexbox布局和网格布局的异同"></a>2.Flexbox布局和网格布局的异同</h2><p>弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。</p>
<h2 id="3-Flex容器属性"><a href="#3-Flex容器属性" class="headerlink" title="3.Flex容器属性"></a>3.Flex容器属性</h2><ul>
<li>flex-direction: row | row-reverse | column column-reverse;主轴方向</li>
<li>flex-wrap: nowrap | wrap | wrap-reverse;是否可以换行</li>
<li>justify-content: flex-start | flex-end | center | space-between | space-around;主轴上的对齐方式</li>
<li>align-items: flex-start | flex-end | center | baseline | stretch;交叉轴的对齐方式</li>
<li>align-content: flex-start | flex-end | center | space-between | space-around | stretch;多行轴线的对齐方式<h2 id="4-Flex项目属性"><a href="#4-Flex项目属性" class="headerlink" title="4.Flex项目属性"></a>4.Flex项目属性</h2></li>
<li>order<br>根据order的值定义项目排列顺序。数值越小，排列越靠前，默认为0</li>
<li>align-self<br>定义单个项目在交叉轴的对齐方式，可覆盖align-items属性</li>
<li>flex-grow<br>定义项目放大比例，默认为0，当容器有剩余空间时不放大.<br>重点在于，每个方块的 flex-grow 和其他方块的是成<strong>比例</strong>的。</li>
<li>flex-shrink<br>定义项目缩小比例。默认为1，随着容器缩小而等比例缩小。<br>如果设置为0，项目将不缩小。</li>
<li>flex-basis<br>定义项目占据的主轴空间（main size）,默认是auto.</li>
<li>flex<br>flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<h2 id="5-屏幕宽度小于640px"><a href="#5-屏幕宽度小于640px" class="headerlink" title="5.屏幕宽度小于640px"></a>5.屏幕宽度小于640px</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@media all and (max-width:640px)&#123;</div><div class="line">   .container&#123;align-items: flex-start;&#125;</div><div class="line">   .box1,.box2,.box3&#123;order: 1;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-Flex属性设置"><a href="#6-Flex属性设置" class="headerlink" title="6.Flex属性设置"></a>6.Flex属性设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">display: flex;</div><div class="line">justify-content: space-between;</div><div class="line">align-items: center;</div><div class="line">flex-direction: row;</div><div class="line">flex-wrap: wrap;  /*是否可以换行（默认不换行）*/</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Baidu_IFE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[baidu_ife_小薇学院总结（三）]]></title>
      <url>https://barryleeweb.github.io/2017/07/12/baidu_ife_%E5%B0%8F%E8%96%87%E5%AD%A6%E9%99%A2%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Task5-零基础HTML及CSS编码（二）"><a href="#Task5-零基础HTML及CSS编码（二）" class="headerlink" title="Task5:零基础HTML及CSS编码（二）"></a>Task5:零基础HTML及CSS编码（二）</h1><h2 id="1-两栏布局（左边自适应，右边固定）"><a href="#1-两栏布局（左边自适应，右边固定）" class="headerlink" title="1.两栏布局（左边自适应，右边固定）"></a>1.两栏布局（左边自适应，右边固定）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#parent &#123;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">#left &#123;</div><div class="line">    margin-right:220px; </div><div class="line">&#125;</div><div class="line">#right &#123;</div><div class="line">    position: absolute; </div><div class="line">    right:0; </div><div class="line">    top:0;</div><div class="line">    width: 200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-出现水平滚动条"><a href="#2-出现水平滚动条" class="headerlink" title="2.出现水平滚动条"></a>2.出现水平滚动条</h2><p>p标签是块状元素，默认是父容器宽度的100%，所以是定宽块状元素<br>右边固定盒子内部p元素，宽度为父元素宽度，右移40%后，在右边外面了。<br>解决：</p>
<ol>
<li>修改p标签</li>
<li>在p中添加margin-right: 40%;将宽度减小</li>
<li>在body添加overflow-x:hidden;</li>
</ol>
<h1 id="Task6-通过HTML及CSS模拟报纸排版"><a href="#Task6-通过HTML及CSS模拟报纸排版" class="headerlink" title="Task6:通过HTML及CSS模拟报纸排版"></a>Task6:通过HTML及CSS模拟报纸排版</h1><h2 id="1-行距、段落间距和首行缩进"><a href="#1-行距、段落间距和首行缩进" class="headerlink" title="1.行距、段落间距和首行缩进"></a>1.行距、段落间距和首行缩进</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">示例：&lt;p style=&quot;line-height:130%;margin:9px;text-indent:2em&quot;&gt;文字内容&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>说明：<br>line-height是行间距属性，margin是段落间距属性；<br>text-indent 的作用使得容器内首行缩进一定单位，上面的2em表示首行缩进2个汉字</p>
<h2 id="2-字体加粗，倾斜"><a href="#2-字体加粗，倾斜" class="headerlink" title="2.字体加粗，倾斜"></a>2.字体加粗，倾斜</h2><p>font-style: oblique;  /<em>倾斜字体</em>/<br>font-weight: bold; /<em>加粗</em>/<br>text-align：justify ; /<em>实现两端对齐文本效果</em>/<br>font-size:12px/24px 黑体;/<em>12px/24px指的是字体的宽度高度单位是像素</em>/<br>text-decoration: underline; /<em>下划线</em>/</p>
<h2 id="3-CSS实现三角形图标"><a href="#3-CSS实现三角形图标" class="headerlink" title="3.CSS实现三角形图标"></a>3.CSS实现三角形图标</h2><p>如果我们要做倒立三角形、向右的、或者向左的三角形，只需要为三角形底部设置边框，两腰边框透明即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">width: 0;</div><div class="line">height: 0;</div><div class="line">border-top: 40px solid transparent;</div><div class="line">border-left: 40px solid #ff0000;</div><div class="line">border-bottom: 40px solid transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Baidu_IFE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[baidu_ife_小薇学院总结（二）]]></title>
      <url>https://barryleeweb.github.io/2017/07/11/baidu_ife_%E5%B0%8F%E8%96%87%E5%AD%A6%E9%99%A2%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Task3-三栏式布局"><a href="#Task3-三栏式布局" class="headerlink" title="Task3:三栏式布局"></a>Task3:三栏式布局</h1><h2 id="1-三栏式布局方法"><a href="#1-三栏式布局方法" class="headerlink" title="1.三栏式布局方法"></a>1.三栏式布局方法</h2><p>方法一：inline-block方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">left,center,right&#123; display：inline-block&#125; /* 包裹作用，不会塌陷 */ </div><div class="line">left&#123;width:200px&#125;</div><div class="line">right&#123;width:120px&#125;</div><div class="line">center&#123;width:calc(100%-200px-120px-40px)&#125; /* 动态计算中间盒子的宽度 */</div></pre></td></tr></table></figure></p>
<p>方法二：float布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;left&quot;&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;  /* 这里将right提到center前面 */</div><div class="line">&lt;div class=&quot;center&quot;&gt;</div><div class="line"></div><div class="line">.left&#123;float:left&#125;</div><div class="line">.center&#123; margin-left: 220px; margin-right: 140px; &#125;</div><div class="line">.right&#123;float: right;&#125;</div></pre></td></tr></table></figure></p>
<p>方法三：Flex布局（新）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.middle&#123;display: flex;&#125;</div><div class="line">.left,.right&#123;width: 100px;&#125;</div><div class="line">.right&#123;order: 2;&#125;</div><div class="line">.main&#123;</div><div class="line">    order: 1;</div><div class="line">    flex: 1; /*让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容*/ </div><div class="line">    margin: 0 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>方法四：圣杯和双飞翼布局（旧）<br>基本思路及区别：<br>1.两种布局的基本构思为：首先让中间层100%宽度占满同一高度的空间，在左右两层被挤出中间层所在区域时， 使用margin-left的负值将左右两个层拉回与中间层同一高度的空间，接下来调整左右两层到指定位置， 最后使用中间层的margin或padding属性使中间层的内容躲出左右两层占住的显示区。</p>
<p>2.两种布局的主要区别在于：圣杯布局采用一个父层包含中间、左右三个子层，设置父层的padding值腾出左右两层的显示区， 并对左右两层使用relative和left、right值调整位置；双飞翼采用中间、左右三层并列，再在中间层里设置一个子层， 设置中间层子层的margin值腾出左右两层的显示区，对左右两层使用margin值即可调整位置；</p>
<p>圣杯html结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;container&quot;&gt;</div><div class="line">    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>圣杯css基本代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#container&#123;</div><div class="line">    padding: 0px 120px 0 140px;/*腾出宽度*/</div><div class="line">    &#125;</div><div class="line">#main&#123;</div><div class="line">    width: 100%;</div><div class="line">    position: relative;</div><div class="line">    &#125;</div><div class="line">#left&#123;</div><div class="line">    width: 140px;</div><div class="line">    margin-left: -100%;/*将left层拉回main层所在高度区域*/</div><div class="line">    left: -140px;/*调整位置*/</div><div class="line">    position: relative;</div><div class="line">    &#125;</div><div class="line">#right&#123;</div><div class="line">    width: 120px;</div><div class="line">    margin-left: -120px;/*将right层拉回main层所在高度区域*/</div><div class="line">    right: -120px;/*调整位置*/</div><div class="line">    position: relative;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>双飞翼html结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;main&quot;&gt;</div><div class="line">    &lt;div id=&quot;main-inner&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div id=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div id=&quot;right&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>双飞翼css基本代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#main&#123;</div><div class="line">    width: 100%;</div><div class="line">    position: relative;</div><div class="line">    &#125;</div><div class="line">#main-inner&#123;</div><div class="line">    margin：0 120px 0 140px；</div><div class="line">    ｝</div><div class="line">#left&#123;</div><div class="line">    width: 140px;</div><div class="line">    margin-left: -100%;/*将left层拉回main层所在高度区域*/</div><div class="line">    &#125;</div><div class="line">#right&#123;</div><div class="line">    width: 120px;</div><div class="line">    margin-left: -120px;/*将right层拉回main层所在高度区域*/</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-box-sizing-属性"><a href="#2-box-sizing-属性" class="headerlink" title="2.box-sizing 属性"></a>2.box-sizing 属性</h2><p>取值说明</p>
<ol>
<li><p>content-box:此值为其默认值，其让元素维持W3C的标准Box Model，也就是说元素的宽度/高度（width/height）等于元素边框宽度（border）加上元素内边距（padding）加上元素内容宽度/高度（content width/height）即：Element Width/Height = border+padding+content width/height。</p>
</li>
<li><p>border-box:此值让元素维持IE传统的Box Model（IE6以下版本），也就是说元素的宽度/高度等于元素内容的宽度/高度。（从上面Box Model介绍可知，我们这里的content width/height包含了元素的border,padding,内容的width/height【此处的内容宽度/高度=width/height-border-padding】）。</p>
</li>
</ol>
<h2 id="3-inline-block之间间距"><a href="#3-inline-block之间间距" class="headerlink" title="3.inline-block之间间距"></a>3.inline-block之间间距</h2><p>元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;space&quot;&gt;</div><div class="line">    &lt;a href=&quot;##&quot;&gt;</div><div class="line">    惆怅&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</div><div class="line">    淡定&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</div><div class="line">    热血&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或者是：</div><div class="line"></div><div class="line">&lt;div class=&quot;space&quot;&gt;</div><div class="line">    &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a</div><div class="line">    &gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a</div><div class="line">    &gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或者是借助HTML注释：</div><div class="line"></div><div class="line">&lt;div class=&quot;space&quot;&gt;</div><div class="line">    &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a&gt;&lt;!--</div><div class="line">    --&gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a&gt;&lt;!--</div><div class="line">    --&gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Task4-定位和居中问题"><a href="#Task4-定位和居中问题" class="headerlink" title="Task4:定位和居中问题"></a>Task4:定位和居中问题</h1><h2 id="1-水平及上下居中"><a href="#1-水平及上下居中" class="headerlink" title="1.水平及上下居中"></a>1.水平及上下居中</h2><p>方法一：绝对定位的居中实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">position: absolute;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">transform: translate(-50%,-50%); /*x轴y轴各位移div盒子的一半*/</div></pre></td></tr></table></figure></p>
<p>方法二：margin:auto实现绝对定位元素的居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  position: absolute; left: 0; top: 0; right: 0; bottom: 0; </div><div class="line">  margin: auto; /* 有了这个就自动居中了 */</div><div class="line">```   	</div><div class="line">方法三：Flex布局方法：</div></pre></td></tr></table></figure></p>
<p>  width:100%;<br>  height:100%;<br>  display: -webkit-flex;<br>  display: flex;<br>  justify-content:center;<br>  align-items:center;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 2.清除浮动</div><div class="line">方法一：overflow:hidden;（或者auto，hidden更好）</div><div class="line"></div><div class="line">方法二：清除浮动更好的方法是clearfix技巧</div><div class="line">“clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪类。使用这些伪类，我们可以在浮动元素的父容器前面和后面创建隐藏元素。“:before”伪类是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪类是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。</div><div class="line"></div><div class="line">一个常见的方法是将定义一个类名，把这个类名加到需要清除浮动的容器上。例如使用“clearfix”清除浮动，Dan Cederholm为容器设置了一个类名“group”。在需要清除浮动的容器上添加这个类名“group”。</div></pre></td></tr></table></figure></p>
<p>.group:before,<br>.group:after {<br>  content: “”;<br>  display: table;<br>}<br>.group:after {<br>  clear: both;<br>}<br>.group {<br>  *zoom: 1;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">## 3.absolute定位初始位置</div><div class="line">在文档流中，定义为position:absolute的元素已经被删除了。</div><div class="line">那它的定位到底是相对于body，还是父级元素呢？</div><div class="line"></div><div class="line">结论如下：</div><div class="line">position:absolute是相对于他的包含块中第一个有position:absolute或relative及 fixed属性的父级元素，如果都没有，就是相对于body。</div><div class="line"></div><div class="line">## 4.border-radius属性</div><div class="line">border-radius属性其实可以分为四个其他的属性：</div><div class="line">border-radius-top-left         /*左上角*/</div><div class="line">border-radius-top-right       /*右上角*/</div><div class="line">border-radius-bottom-right /*右下角*/</div><div class="line">border-radius-bottom-left   /*左下角*/</div><div class="line">//提示：按顺时针方式</div><div class="line"></div><div class="line">制作半圆：</div></pre></td></tr></table></figure></p>
<p>width:100px;<br>    height:50px;//高度是宽度的一半<br>    background-color:#000;<br>border-radius:50px 50px 0 0;//左上和右上至少为height值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">画实心圆</div></pre></td></tr></table></figure></p>
<p>width:100px;<br>      height:100px;<br>    background-color:#cb18f8;<br>      border-radius:50px;<br>   （或者border-radius:50%）<br>```</p>
]]></content>
      
        <categories>
            
            <category> Baidu_IFE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[baidu_ife_小薇学院总结（一）]]></title>
      <url>https://barryleeweb.github.io/2017/07/11/baidu_ife_%E5%B0%8F%E8%96%87%E5%AD%A6%E9%99%A2%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Task1-零基础HTML编码"><a href="#Task1-零基础HTML编码" class="headerlink" title="Task1:零基础HTML编码"></a>Task1:零基础HTML编码</h1><h2 id="1-新标签"><a href="#1-新标签" class="headerlink" title="1.新标签"></a>1.新标签</h2><p>&emsp;&emsp;在学习html5的过程中，知道了一些新的标签，能够更清晰的表达文档的结构（原来都是用div，可能加上id或者class来划分）。</p>
<ul>
<li>header 页面头部／标题／logo／搜索表单 等等</li>
<li>nav 任何有导航性质的标签都可以用到，比如页面中的导航，可以有多个</li>
<li>aside 和主要内容不相关的内容，工具内容／广告什么的</li>
<li>article 表示独立的可重复的结构：论坛的帖子／博客的评论</li>
<li>section 表示文档中的一个区域：一般会带一个标题　相临的section之间是有相关性的，article则不相关，是独立的</li>
<li>footer 章节的尾部：版权信息／相关文档／一些独立内容的尾部也可以用到</li>
</ul>
<a id="more"></a>
<h2 id="2-打开新窗口："><a href="#2-打开新窗口：" class="headerlink" title="2.打开新窗口："></a>2.打开新窗口：</h2><p><code>&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_Blank&quot;&gt;百度&lt;/a&gt;</code><br>_Blank是新窗口<br>_Self是自身<br>_Parent是父窗口<br>_Top是顶层窗口</p>
<p>.空格：在html中输入空格是没有作用的，需要输入&amp;nbsp这个代码</p>
<h2 id="3-表格："><a href="#3-表格：" class="headerlink" title="3.表格："></a>3.表格：</h2><p>加边框<code>&lt;table border=&quot;1&quot;&gt; &lt;/table&gt;</code><br>表格的跨行和跨列：colspan  rowspan<br>colspan 属性规定单元格可横跨的列数。</p>
<h2 id="4-表单"><a href="#4-表单" class="headerlink" title="4.表单"></a>4.表单</h2><p>&emsp;&emsp;label标签，为input元素定义标注，改进了表单控件的可用性，当你点击到label标签时，会自动聚焦到对应控件上。<br><code>&lt;label&gt;请输入用户名&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;/label&gt;</code></p>
<h2 id="5-Ife-baidu-com页面HTML结构："><a href="#5-Ife-baidu-com页面HTML结构：" class="headerlink" title="5.Ife.baidu.com页面HTML结构："></a>5.Ife.baidu.com页面HTML结构：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  …</div><div class="line">  &lt;meta name=”viewport” content=””&gt;</div><div class="line">&lt;meta name=”keywords” content=””&gt;</div><div class="line">&lt;meta name=”description” content=””&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">&lt;header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;/header&gt;</div><div class="line">&lt;main&gt;&lt;div&gt;&lt;/div&gt;&lt;/main&gt;</div><div class="line">&lt;footer&gt;&lt;/footer&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h1 id="Task2-零基础HTML编码及CSS编码（一）"><a href="#Task2-零基础HTML编码及CSS编码（一）" class="headerlink" title="Task2:零基础HTML编码及CSS编码（一）"></a>Task2:零基础HTML编码及CSS编码（一）</h1><h2 id="1-关于外边距的合并的问题"><a href="#1-关于外边距的合并的问题" class="headerlink" title="1.关于外边距的合并的问题"></a>1.关于外边距的合并的问题</h2><p>&emsp;&emsp;外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。<br>解决办法：</p>
<ol>
<li>都用float来定位（有条件要求，适用范围较广）</li>
<li>为父元素添加overflow不为visiable 的属性 （适用范围极广，推荐使用）</li>
<li>为元素添加border（一般不用）</li>
<li>使用绝对定位（适用范围较窄）</li>
<li>父元素增加padding-top属性（改变尺寸，不建议使用）</li>
</ol>
<h2 id="2-对于便签选择器的灵活运用"><a href="#2-对于便签选择器的灵活运用" class="headerlink" title="2.对于便签选择器的灵活运用"></a>2.对于便签选择器的灵活运用</h2><p>.SideBar&gt;h1;子选择器<br>.Gallery img包含选择器<br>.pic01,.pic02,.pic03分组选择器</p>
<p>：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。</p>
<p>注意：后代选择器，后面不能跟分组选择器，只会作用第一个。</p>
<p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。<br>&emsp;&emsp;Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）<br>&emsp;&emsp;使用公式 (an + b)。描述：表示周期的长度，n 是计数器（从 0 开始），b 是偏移值。<br>:last-child 选择器匹配属于其父元素的最后一个子元素的每个元素。</p>
<h2 id="3-使用超链接a标签的伪类"><a href="#3-使用超链接a标签的伪类" class="headerlink" title="3.使用超链接a标签的伪类"></a>3.使用超链接a标签的伪类</h2><p>a:link {color: #FF0000}        /<em> 未访问的链接 </em>/<br>a:visited {color: #00FF00}    /<em> 已访问的链接 </em>/<br>a:hover {color: #FF00FF}    /<em> 鼠标移动到链接上 </em>/<br>a:active {color: #0000FF}    /<em> 选定的链接 </em>/</p>
<h2 id="4-CSS3-box-shadow"><a href="#4-CSS3-box-shadow" class="headerlink" title="4.CSS3 box-shadow"></a>4.CSS3 box-shadow</h2><p>box-shadow: h-shadow v-shadow blur spread color inset;</p>
<p>h-shadow    必需的。水平阴影的位置。允许负值<br>v-shadow    必需的。垂直阴影的位置。允许负值<br>blur    可选。模糊距离<br>spread    可选。阴影的大小<br>color    可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表<br>inset    可选。从外层的阴影（开始时）改变阴影内侧阴影</p>
<h2 id="5-首行文本的缩进"><a href="#5-首行文本的缩进" class="headerlink" title="5.首行文本的缩进"></a>5.首行文本的缩进</h2><p>text-indent: 2em;  首行空2个字<br>text-indent 属性规定文本块中首行文本的缩进。</p>
<h2 id="6-Table"><a href="#6-Table" class="headerlink" title="6.Table"></a>6.Table</h2><p>border-collapse 属性设置表格的边框是否被合并为一个单一的边框<br>separate    默认值。边框会被分开。<br>collapse    如果可能，边框会合并为一个单一的边框</p>
<h2 id="7-表单的布局"><a href="#7-表单的布局" class="headerlink" title="7.表单的布局"></a>7.表单的布局</h2><p>左侧对齐：<br>左侧文字用<span>,定位absolute，left：40%<br>右侧对齐；<br>右侧input用<label>包裹，定位relative，left：40%</label></span></p>
]]></content>
      
        <categories>
            
            <category> Baidu_IFE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkdownPad如何写博客]]></title>
      <url>https://barryleeweb.github.io/2017/07/04/MarkdownPad%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>&emsp;&emsp;标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div></pre></td></tr></table></figure></p>
<p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。<br><a id="more"></a></p>
<h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><p>在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>1 </li>
<li>2 </li>
<li>3</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><p>在文本前加入 &gt; 这种尖括号（大于号）为引用的格式</p>
<blockquote>
<p>这里是引用</p>
</blockquote>
<h2 id="4-图片和链接"><a href="#4-图片和链接" class="headerlink" title="4.图片和链接"></a>4.图片和链接</h2><p>插入链接与插入图片的语法很像，区别在一个 !号</p>
<p>图片为：<code>![](){ImgCap}{/ImgCap}</code><br><img src="http://mouapp.com/Mou_128.png" alt="Mou icon"></p>
<p>链接为：<code>[]()</code><br><a href="http：//www.baidu.com">baidu</a></p>
<h2 id="5-粗体和斜体"><a href="#5-粗体和斜体" class="headerlink" title="5.粗体和斜体"></a>5.粗体和斜体</h2><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。<br><em>斜体</em><br><strong>粗体</strong> </p>
<h2 id="6-表格"><a href="#6-表格" class="headerlink" title="6.表格"></a>6.表格</h2><p>每一行的元素由<code>|</code>隔开</p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h2 id="7-代码框"><a href="#7-代码框" class="headerlink" title="7.代码框"></a>7.代码框</h2><p>在文章里优雅的引用代码框，只需要用两个 ` 把中间的代码包裹起来<br>代码块用三个`表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8.分割线"></a>8.分割线</h2><p>分割线的语法只需要三个 * 号</p>
<hr>
<h2 id="9-转义字符"><a href="#9-转义字符" class="headerlink" title="9.转义字符"></a>9.转义字符</h2><p>\ 反斜杠<br>` 反引号<br>* 星号<br>_ 下划线<br>{} 大括号<br>[] 中括号<br>() 小括号<br># 井号<br>+ 加号<br>- 减号<br>. 英文句号<br>! 感叹号</p>
<h2 id="10-快捷键"><a href="#10-快捷键" class="headerlink" title="10.快捷键"></a>10.快捷键</h2><ol>
<li>ctrl+1 一级标题 </li>
<li>ctrl+2 二级标题 </li>
<li>ctrl+shift+o 有序列表</li>
<li>ctrl+u 无序列表</li>
<li>ctrl+g 插入图片</li>
<li>ctrl+l 插入超链接</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://barryleeweb.github.io/2017/03/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
